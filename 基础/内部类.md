# 内部类

内部类是定义在另一个类（称为**外部类**）内部的类，它是 Java 中实现封装和代码复用的重要特性。内部类可以直接访问外部类的所有成员（包括私有成员），而外部类访问内部类成员则需要通过内部类的实例。

---

## 内部类的分类

### 一、静态内部类（嵌套类）

静态内部类使用`static`修饰，属于**外部类本身**（而非外部类的实例），因此也被称为 “嵌套类”。

**特点：**

1. 只能访问外部类的**静态成员**（包括静态变量、静态方法，私有静态成员也可访问）；
2. 可以定义静态成员（变量、方法）；
3. 创建对象时无需依赖外部类实例。

```java
public class OuterClass {
    private static String staticField = "外部类静态变量";
    private String instanceField = "外部类实例变量";

    // 静态内部类
    public static class StaticInnerClass {
        public void show() {
            System.out.println(staticField); // 可访问外部类静态成员
            // System.out.println(instanceField); // 错误：不能访问外部类实例成员
        }
    }

    public static void main(String[] args) {
        // 创建静态内部类对象：外部类名.内部类名
        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();
        inner.show(); // 输出：外部类静态变量
    }
}
```

### 二、成员内部类

成员内部类没有`static`修饰，属于**外部类的实例成员**。

**特点：**

1. 可以访问外部类的**所有成员**（静态、实例，包括私有）；
2. 不能定义静态成员（除非是`static final`常量）；
3. 创建对象时必须先创建外部类实例，再通过外部类实例创建内部类实例。

```java
public class OuterClass {
    private String outerField = "外部类实例变量";
    private static String staticOuterField = "外部类静态变量";

    // 成员内部类
    public class MemberInnerClass {
        public void show() {
            System.out.println(outerField); // 访问外部类实例成员
            System.out.println(staticOuterField); // 访问外部类静态成员
        }
    }

    public static void main(String[] args) {
        // 1. 创建外部类实例
        OuterClass outer = new OuterClass();
        // 2. 通过外部类实例创建内部类实例
        OuterClass.MemberInnerClass inner = outer.new MemberInnerClass();
        inner.show(); // 输出：外部类实例变量 \n 外部类静态变量
    }
}
```

### 三、局部内部类

局部内部类定义在**外部类的方法或代码块**中，作用域仅限于当前方法 / 代码块。

**特点：**

1. 可以访问外部类的所有成员；
2. 可以访问方法中的`final`变量（Java 8 + 支持 “effectively final” 变量，即未显式声明`final`但实际不可修改的变量）；
3. 不能使用访问修饰符（`public`/`private`/`protected`），也不能用`static`修饰。

```java
public class OuterClass {
    private String outerField = "外部类变量";

    public void outerMethod() {
        final String methodVar = "方法局部变量"; // Java 8+可省略final

        // 局部内部类（定义在方法中）
        class LocalInnerClass {
            public void show() {
                System.out.println(outerField); // 访问外部类成员
                System.out.println(methodVar); // 访问方法局部变量
            }
        }

        // 在方法内创建局部内部类实例并调用
        LocalInnerClass inner = new LocalInnerClass();
        inner.show();
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.outerMethod(); // 输出：外部类变量 \n 方法局部变量
    }
}
```

### 四、匿名内部类

匿名内部类是**没有类名**的局部内部类，通常用于快速创建接口 / 抽象类的实例，或重写现有类的方法，适合 “一次性使用” 的场景。

**特点**：

1. 没有类名，无法单独定义，必须在创建实例时同时定义；
2. 继承一个父类或实现一个接口（但不能同时继承和实现）；
3. 没有构造方法（因为没有类名）；
4. 可以访问外部类成员和方法中的`effectively final`变量。

匿名类实现接口：

```java
// 定义接口
interface MyInterface {
    void doSomething();
}

public class OuterClass {
    public static void main(String[] args) {
        // 匿名内部类实现MyInterface
        MyInterface inner = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println("匿名内部类实现接口方法");
            }
        };
        inner.doSomething(); // 输出：匿名内部类实现接口方法
    }
}
```

重写类方法：

```JAVA
public class OuterClass {
    public static void main(String[] args) {
        // 匿名内部类重写Runnable的run方法
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("线程执行匿名内部类逻辑");
            }
        }).start(); // 输出：线程执行匿名内部类逻辑
    }
}
```

## 内部类的优缺点	

**优点：**

1. **封装性更强**：内部类可以隐藏在外部类中，不对外暴露；
2. **访问权限灵活**：能直接访问外部类的私有成员，无需通过 getter/setter；
3. **代码紧凑**：适合处理与外部类紧密耦合的逻辑，简化代码结构（如 GUI 事件处理）。

**缺点：**

1. **可读性下降**：嵌套层次过多会增加代码复杂度；
2. **编译后文件复杂**：每个内部类会生成独立的`.class`文件（命名规则：`外部类名$内部类名.class`，匿名内部类为`外部类名$数字.class`）；
3. **内存管理**：成员内部类会隐式持有外部类实例的引用，可能导致外部类无法被 GC 回收（内存泄漏风险）。