# 单例设计模式

**确保一个类在整个 Java 应用程序的生命周期中，仅存在一个实例对象，并且提供一个全局唯一的访问点（静态方法）供外部获取该实例**。

---

单例模式通过 “限制实例化” 和 “统一访问”，解决上述问题，核心思想可概括为：

1. **禁止外部创建实例**：私有化构造器（`private` 修饰），阻止外部通过 `new 类名()` 创建多个对象；
2. **内部创建唯一实例**：在类内部定义静态成员（类级别，不依赖对象）存储唯一实例；
3. **提供全局访问点**：通过静态方法（如 `getInstance()`）向外部暴露该实例，确保所有调用都获取同一个对象。

## 实现方式

### 1.饿汉式

```java
public class SingletonHungry {
    //内部构造器，防止外部构造实例
    private SingletonHungry() {};
    //在类内创建唯一实例,类加载时初始化
    private static final SingletonHungry instance = new SingletonHungry();
    //静态方法返回实例
    public static SingletonHungry getInstance() {
        return instance;
    }
}
```

优点：代码简洁、线程安全（类加载机制保证）、效率高（无同步开销）；

缺点：无懒加载（类加载时就创建实例），若实例占用资源大（如数据库连接池），且程序全程未使用，会造成资源浪费。

### 2.饿汉式（静态代码块）—— 支持复杂初始化

```java
public class SingletonHungryBlock {
    private SingletonHungryBlock() {}

    // 2. 静态变量（仅声明）
    private static final SingletonHungryBlock INSTANCE;

    // 3. 静态代码块：复杂初始化（类加载时执行）
    static {
        // 模拟读取配置文件、初始化参数等复杂逻辑
        String config = loadConfig();
        INSTANCE = new SingletonHungryBlock(config);
    }

    public static SingletonHungryBlock getInstance() {
        return INSTANCE;
    }

    // 模拟复杂初始化方法
    private static String loadConfig() {
        return "app.config";
    }
}
```

优点：线程安全，可以进行复杂初始化

缺点：同上

### 3.懒汉式（线程不安全）

```java
public class SingletonLazyUnsafe {
    private SingletonLazyUnsafe() {}

    // 仅声明静态变量，未初始化
    private static SingletonLazyUnsafe INSTANCE;

    // 全局访问点：首次调用时创建实例
    public static SingletonLazyUnsafe getInstance() {
        // 问题：多线程同时进入if，会创建多个实例
        if (INSTANCE == null) {
            INSTANCE = new SingletonLazyUnsafe();
        }
        return INSTANCE;
    }
}
```

缺点：多线程环境下，多个线程可能同时进入 `if (INSTANCE == null)` 分支，导致创建多个实例，破坏单例特性。

### 4.懒汉式(线程安全）——安全但低效

在 `getInstance()` 方法上添加 `synchronized` 关键字

```java
public class SingletonLazyUnsafe {
    private SingletonLazyUnsafe() {}

    private static SingletonLazyUnsafe INSTANCE;

       // 同步方法：多线程串行执行
    public static synchronized SingletonLazyUnsafe getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new SingletonLazyUnsafe();
        }
        return INSTANCE;
    }
}
```

优点：线程安全

缺点：`synchronized` 修饰整个方法，多线程即使实例已创建（无需初始化），仍需排队等待，并发效率极低（适合单线程或低并发场景）。

### 5. 懒汉式（双重检查锁 DCL）—— 线程安全 + 高效 + 懒加载

```java
public class SingletonLazyDCL {
    private SingletonLazyDCL() {};
    //volatile 是 Java 中用于修饰变量的关键字，核心作用是保证变量的可见性、禁止指令重排序，但不保证原子性
    private static  volatile SingletonLazyDCL INSTANCE;

    private static SingletonLazyDCL getInstance() {
        //第一次检测，避免实例已创建后，线程仍进入同步块（减少锁竞争）
        if(INSTANCE == null) {
            //锁定类对象（仅初始化时需要同步）
            synchronized (SingletonLazyDCL.class) {
                //第二次检测，防止多个线程等待锁时，前一个线程已创建实例，后续线程重复创建
                if(INSTANCE == null) {
                    INSTANCE = new SingletonLazyDCL();
                }
            }
        }
        return INSTANCE;
    }
}
```

优点：线程安全、支持懒加载、高效（仅初始化时同步，后续直接返回）；

缺点：实现稍复杂，需理解 `volatile` 和双重检查的作用；仍可能被反射破坏。

适用于高并发环境、实例占用资源大、需要懒加载的场景（如数据库连接池、线程池）。

### 6. 静态内部类（Holder 模式）—— 推荐实现

利用 Java 静态内部类的特性：

- 静态内部类不会随外部类加载而加载，仅在首次访问时加载（实现懒加载）；
- 类加载机制保证线程安全（静态内部类加载时仅创建一次实例）；
- 无需同步关键字，效率高。

```java
public class SingletonHolder {
    private SingletonHolder() {}

    // 静态内部类（Holder）：仅在首次访问时加载
    private static class Holder {
        // 静态常量：内部类加载时创建唯一实例
        private static final SingletonHolder INSTANCE = new SingletonHolder();
    }

    // 全局访问点：首次调用时触发Holder类加载
    public static SingletonHolder getInstance() {
        return Holder.INSTANCE;
    }
}
```

优点：线程安全、懒加载、效率高、代码简洁（比 DCL 简单）；

缺点：仍可能被反射破坏。

大多数场景下的首选实现，兼顾简洁性和性能。

### 7. 枚举单例 —— 最安全的实现

```java
public class SingletonEnum {
    //使用枚举类型实现单例模式
    public enum Singleton {
        INSTANCE;
        //可以添加其他方法和属性
        public void someMethod() {
            System.out.println("Singleton Enum Method Called");
        }
    }

    //全局访问点
    public static Singleton getInstance() {
        return Singleton.INSTANCE;
    }
}

```

优点：线程安全、懒加载（枚举实例在首次访问时创建）、防反射破坏、防序列化破坏、代码极简；

缺点：JDK1.5+ 才支持（目前主流 JDK 均满足）；枚举实例无法延迟初始化复杂逻辑（需在构造器中完成）。

对安全性要求极高的场景（如支付、权限管理），是《Effective Java》作者推荐的 “最佳单例实现”。

---

总结一下

- 简单场景、资源占用少 → 饿汉式；
- 高并发、懒加载、追求效率 → 静态内部类（Holder 模式）；
- 安全性要求极高（防反射、序列化） → 枚举单例；
- 复杂初始化、高并发 → 双重检查锁（DCL）。
