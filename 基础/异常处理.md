# 异常处理

Java 的异常处理机制是程序应对 ** 运行时非正常情况（异常）** 的核心手段，它允许程序在异常发生时捕获错误、处理错误，甚至优雅地恢复运行，避免程序直接崩溃。其设计基于 “异常对象” 封装错误信息，并通过结构化的语法（`try-catch-finally`、`throw`、`throws`）实现异常的捕获与传播。

---

### 异常的本质与层次结构

Java 中所有异常的根类是`java.lang.Throwable`，它派生出两个核心子类：**`Error`**（错误）和 **`Exception`**（异常），二者共同构成了异常体系的基础。

**体系结构**：

```txt
Throwable
├─ Error（系统错误，程序无法处理）
│  ├─ VirtualMachineError（虚拟机错误：如OutOfMemoryError、StackOverflowError）
│  ├─ LinkageError（链接错误：如NoClassDefFoundError）
│  └─ AWTError（AWT组件错误）
└─ Exception（程序可处理的异常）
   ├─ 受检异常（Checked Exception，编译时强制处理）
   │  ├─ IOException（IO操作异常：如FileNotFoundException）
   │  ├─ SQLException（数据库操作异常）
   │  └─ ClassNotFoundException（类找不到异常）
   └─ 非受检异常（Unchecked Exception，编译时不强制处理）
      └─ RuntimeException（运行时异常）
         ├─ NullPointerException（空指针异常）
         ├─ ArrayIndexOutOfBoundsException（数组越界）
         ├─ ClassCastException（类型转换异常）
         ├─ IllegalArgumentException（非法参数）
         └─ ArithmeticException（算术错误：如除以0）
```

**具体说明**：

- **Error（错误）**：由 JVM 或系统底层抛出，属于**不可恢复的严重错误**，程序无法捕获和处理（捕获也无意义）。例如：

  `StackOverflowError`：递归过深导致栈溢出；

  `OutOfMemoryError`：内存耗尽（OOM）。

- **Exception（异常）**：程序运行时的非严重错误，可通过代码处理：

  **受检异常（Checked）**：编译器强制要求处理（要么`try-catch`捕获，要么`throws`声明抛出），否则编译失败。例如`IOException`、`SQLException`。

  **非受检异常（Unchecked）**：`RuntimeException`及其子类，编译器不强制处理，通常由代码逻辑错误导致（如空指针、数组越界）。

---

### 异常处理的核心机制

Java 通过**捕获异常**和**抛出异常**两种方式处理异常，核心语法包括`try-catch-finally`、`throw`、`throws`，以及 JDK 7 引入的`try-with-resources`（自动资源管理）。

#### 异常捕获：try-catch-finally

语法结构：

```java
try {
    // 可能抛出异常的代码块（监控区）
} catch (异常类型1 异常变量) {
    // 处理异常类型1的逻辑
} catch (异常类型2 异常变量) {
    // 处理异常类型2的逻辑（需按“子类→父类”顺序排列）
} finally {
    // 无论是否发生异常，都会执行的代码块（如资源释放）
}
```

**try块**：必须存在，包含可能触发异常的代码。若代码正常执行，跳过所有 catch 块；若抛出异常，JVM 会匹配 catch 块的异常类型。

**catch块**：可选（可多个），用于捕获特定类型的异常。**多个 catch 块需按 “子类异常在前，父类异常在后”**（否则父类会覆盖子类，编译报错）。

**finally 块**：可选，用于执行**必须完成的操作**（如关闭文件流、数据库连接）。**即使 try/catch 中执行了`return`或`System.exit(0)`（后者会终止 JVM，finally 不执行），finally 仍会执行**。

示例：

```java
try {
    int[] arr = {1,2};
    System.out.println(arr[3]); // 抛出ArrayIndexOutOfBoundsException
} catch (ArrayIndexOutOfBoundsException e) { // 子类异常先捕获
    System.out.println("数组越界：" + e.getMessage());
} catch (RuntimeException e) { // 父类异常后捕获
    System.out.println("运行时异常：" + e.getMessage());
}finally {
    System.out.println("无论是否异常，都会执行的代码");
}
```

#### 自动资源管理：`try-with-resources`（JDK 7+）

针对实现了`AutoCloseable`接口的资源（如`FileInputStream`、`Connection`），可自动关闭资源，替代`finally`块的手动释放，语法更简洁

语法结构：

```java
try (资源声明1; 资源声明2) { // 资源会在try结束后自动调用close()
    // 使用资源的代码
} catch (异常类型 e) {
    // 异常处理
}
```

示例：

```java
try (FileInputStream fis = new FileInputStream("test.txt")) {
    // 读取文件
} catch (IOException e) {
    e.printStackTrace();
} // fis自动关闭，无需finally
```

#### 抛出异常：`throw`与`throws`

当方法无法处理异常时，可选择**手动抛出异常**（`throw`）或**声明异常交由上层处理**（`throws`）。

**throw**:用于在代码中主动触发异常（如业务逻辑校验失败）

语法：`throw new 异常类型(异常信息);`

```java
public void setAge(int age) {
    if (age < 0 || age > 150) {
        // 手动抛出非法参数异常
        throw new IllegalArgumentException("年龄必须在0-150之间");
    }
    this.age = age;
}
```

**throws**：用于在方法签名上标注该方法**可能抛出的异常类型**，将异常处理责任交给调用者（上层方法）,对于调用者来说，要么处理该异常，要么继续throws，将异常继续抛给上层调用者,**如果直到main层依旧没有处理该异常，那么程序将会停止执行**

语法：`方法名(参数) throws 异常类型1, 异常类型2 { ... }`

受检异常声明：

```java
public void readFile() throws IOException { // 声明可能抛出IOException
    FileInputStream fis = new FileInputStream("test.txt");
}

// 调用者必须处理该异常（try-catch或继续throws）
public static void main(String[] args) {
    try {
        readFile();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

---

### 自定义异常

定义规则

- 继承`Exception`：成为**受检异常**（编译时强制处理）；
- 继承`RuntimeException`：成为**非受检异常**（编译时不强制处理）。

```java
import java.io.Serial;

public class DIY_Exception extends Exception {
    //序列版本号
    @Serial
    private static final long serialVersionUID = 1L;
    //无参构造器
    public DIY_Exception() {
    super();
    }
    //有参构造器,带有异常信息
    public DIY_Exception(String message) {
        super(message);
    }
    //有参构造器,带有异常信息和异常原因（支持链式异常）
    public DIY_Exception(String message, Throwable cause) {
        super(message, cause);
    }
}
```

对于`serialVersionUID`这是序列版本号，对于自定义异常，尽量进行显式声明

**选择`Exception` 还是`RuntimeException`?**

当异常是**外部环境 / 不可控因素导致**、且**调用者有能力合理处理并恢复**时，使用受检异常。

典型场景： 

1. **外部资源操作失败**：如数据库连接失败、文件不存在、网络请求超时等（调用者可重试或提示用户）；
2. **业务规则的可恢复违反**：如 “用户余额不足”（调用者可引导用户充值）、“订单已被锁定”（调用者可等待解锁后重试）；
3. **协议 / 接口调用失败**：如调用第三方 API 返回错误码（调用者可根据码值处理）。

当异常是**程序逻辑错误导致**、且 **调用者无法恢复（只能避免）**时，使用非受检异常。

典型场景：

1. **参数非法**：如传递负数年龄、空指针参数、超出范围的索引等（调用者应提前校验参数）；
2. **逻辑状态错误**：如 “调用未初始化的对象方法”“重复添加已存在的主键”（属于代码逻辑漏洞）；
3. **不可恢复的系统错误**：如 “缓存连接池耗尽”（虽为外部因素，但调用者无法即时处理，需上层监控告警）

### 常见异常类型速览

| 异常类型                         | 分类   | 典型场景                              |
| -------------------------------- | ------ | ------------------------------------- |
| `NullPointerException`           | 非受检 | 调用 null 对象的方法 / 属性           |
| `ArrayIndexOutOfBoundsException` | 非受检 | 数组下标越界                          |
| `ClassCastException`             | 非受检 | 强制类型转换失败（如 String→Integer） |
| `IllegalArgumentException`       | 非受检 | 参数不合法                            |
| `ArithmeticException`            | 非受检 | 除以 0 等算术错误                     |
| `IOException`                    | 受检   | 文件读写失败、网络连接异常            |
| `SQLException`                   | 受检   | 数据库操作失败（如 SQL 语法错误）     |
| `ClassNotFoundException`         | 受检   | 类加载失败（如 Class.forName）        |
| `StackOverflowError`             | Error  | 递归过深                              |
| `OutOfMemoryError`               | Error  | 内存耗尽（如创建超大数组）            |

