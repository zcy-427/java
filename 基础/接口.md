# 接口

接口（`interface`）是 Java 中用于**定义 “行为契约”\**的核心语法结构，本质是一套 “规则标准”—— 只规定类 “必须做什么”，不关注 “具体怎么做”。它强调\**“has-a” 关系**

---

## 语法

定义语法：

```java
[public] interface 接口名 [extends 父接口1, 父接口2...] {
    // 常量（默认 public static final）
    数据类型 常量名 = 值;

    // 抽象方法（默认 public abstract）
    返回值类型 方法名(参数列表);

    // 默认方法（JDK8+，带方法体）
    default 返回值类型 方法名(参数列表) {
        // 实现逻辑
    }

    // 静态方法（JDK8+，带方法体）
    static 返回值类型 方法名(参数列表) {
        // 实现逻辑
    }

    // 私有方法（JDK9+，辅助方法）
    private 返回值类型 方法名(参数列表) {
        // 实现逻辑
    }
}
```

类实现接口语法：

```java
[public] class 类名 [extends 父类] implements 接口1, 接口2... {
    // 必须实现所有抽象方法（除非是抽象类）
    @Override
    public 返回值类型 抽象方法名(参数列表) {
        // 实现逻辑
    }

    // 可重写默认方法（可选）
    @Override
    public 返回值类型 默认方法名(参数列表) {
        // 自定义实现
    }
}
```

示例：

```java
public interface work {
    //默认public static final
    int worktime=8;
    //默认public abstract
    void dowork();
     default void eat() {
         System.out.println("吃东西");
     }
}

public class Person implements work{
    public void work()
    {
      System.out.println("工作" + worktime + "小时");
	}
}

```

---

## jdk8+的接口新特性

### 1.默认方法（`default`）

实现类可直接继承默认方法，也可重写（重写时去掉 `default` 修饰符）；

若实现类同时实现多个接口，且接口中有同名默认方法，**必须显式重写**（避免冲突）。

```java
interface A {
    default void show() {
        System.out.println("接口 A 的默认方法");
    }
}

interface B {
    default void show() {
        System.out.println("接口 B 的默认方法");
    }
}

// 实现类必须重写 show()，否则编译报错
class C implements A, B {
    @Override
    public void show() {
        // 可选：调用指定接口的默认方法
        A.super.show(); // 调用接口 A 的 show()
        B.super.show(); // 调用接口 B 的 show()
        System.out.println("类 C 自定义的 show()");
    }
}
```

### 2. 静态方法（`static`）

由`static`修饰，有方法体，通常用于工具方法

- 只能通过接口名调用（不能通过实现类对象调用）；
- 不能被实现类重写（实现类可定义同名静态方法，但属于 “隐藏” 而非 “重写”）。

### 3.私有方法（`private/private static` jdk9+)

封装默认方法 / 静态方法中的公共逻辑，避免代码冗余，且只能在接口内部调用。

```java
interface Calculator {
    // 默认方法：加法
    default int add(int a, int b) {
        log("执行加法"); // 调用私有方法
        return a + b;
    }

    // 默认方法：减法
    default int subtract(int a, int b) {
        log("执行减法"); // 调用私有方法
        return a - b;
    }

    // 私有方法：公共日志逻辑
    private void log(String msg) {
        System.out.println("[日志] " + msg);
    }

    // 私有静态方法：公共工具逻辑
    private static int checkNum(int num) {
        return num < 0 ? 0 : num; // 非负数校验
    }

    // 静态方法：乘法
    static int multiply(int a, int b) {
        int aValid = checkNum(a); // 调用私有静态方法
        int bValid = checkNum(b);
        return aValid * bValid;
    }
}
```

---

## 特殊接口

### 1. 函数式接口（Functional Interface）

**仅有一个抽象方法**的接口（可包含多个默认方法 / 静态方法），是 Lambda 表达式的 “载体”。

- 用 `@FunctionalInterface` 注解标记（编译器会校验是否符合函数式接口规范）；
- 支持 Lambda 表达式、方法引用等简化写法。

```JAVA
@FunctionalInterface
public interface functional_interface {
    void function();

    default void function2() {
        System.out.println("这是一个默认方法");
    }
}
```

main:

```java
functional_interface demo=()->System.out.println("函数式接口");
demo.function();
demo.function2();
```

### 2. 标记接口（Marker Interface）

常见示例

- `java.io.Serializable`：标记类可序列化；
- `java.lang.Cloneable`：标记类可调用 `clone()` 方法；
- `java.util.RandomAccess`：标记集合支持快速随机访问（如 `ArrayList`）。

示例：

```java
// 实现 Serializable 接口，标记该类可序列化
class User implements Serializable {
    private String name;
    private int age;
    // 构造器、getter/setter 省略
}
```

---

## 典型应用场景

### 1. 定义行为规范

为不同类制定统一的行为标准

```java
public interface compare_to<T> {
    int compareTo(T o);
}
class Student implements Comparable<Student> {
    private int score;

    @Override
    public int compareTo(Student o) {
        return this.score - o.score; // 按分数升序比较
    }
}
```

### 2. 实现策略模式

通过接口封装不同策略，动态切换实现逻辑：

```java
// 支付策略接口
interface PaymentStrategy {
    void pay(double amount);
}

// 支付宝支付
class AliPay implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("支付宝支付" + amount + "元");
    }
}

// 微信支付
class WeChatPay implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("微信支付" + amount + "元");
    }
}

// 支付工具类（动态切换策略）
class PaymentTool {
    private PaymentStrategy strategy;

    public PaymentTool(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void pay(double amount) {
        strategy.pay(amount);
    }
}
        
```

### 3. 解耦代码（依赖倒置原则）

高层模块依赖接口，而非具体实现类，降低耦合：

```java
// 数据访问接口
interface UserDao {
    void save(User user);
}

// MySQL 实现
class UserDaoMySQL implements UserDao {
    @Override
    public void save(User user) {
        System.out.println("MySQL 保存用户");
    }
}

// Oracle 实现
class UserDaoOracle implements UserDao {
    @Override
    public void save(User user) {
        System.out.println("Oracle 保存用户");
    }
}

// 业务层依赖接口，而非具体实现
class UserService {
    private UserDao userDao;

    // 通过构造器注入不同实现
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    public void addUser(User user) {
        userDao.save(user);
    }
}
```

