Java 反射（Reflection）是指**程序在运行时动态获取类的完整信息（属性、方法、构造器、父类、接口、注解等），并能动态调用对象的方法、修改属性值** 的能力。
正常情况下，Java 代码的执行是 “编译期确定、运行期执行”，而反射打破了这一限制，让程序在运行时才决定操作的类和方法，是 Java 动态性的核心体现。

## 反射的核心基础：Class 类
反射的入口是 `java.lang.Class` 类 ——**每个类在 JVM 中都有且仅有一个对应的 Class 对象**，它保存了该类的所有元数据（类名、父类、接口、字段、方法等）。

> [!NOTE] 补充
> - 基本类型的 Class 对象：`int.class`、`boolean.class`（包装类的`TYPE`属性等价于基本类型 Class，如`Integer.TYPE == int.class`）；
> - 数组的 Class 对象：`String[].class`、`int[][].class`；
> - 枚举、注解、接口都有对应的 Class 对象。

### 获取 Class 对象的 3 种方式

|方式|示例|特点|
|---|---|---|
|类名.class|`Class<String> cls = String.class;`|编译期确定，最安全、高效，无需实例|
|对象.getClass ()|`String str = "test"; Class<?> cls = str.getClass();`|运行时获取，需先创建对象|
|Class.forName (全限定类名)|`Class<?> cls = Class.forName("java.lang.String");`|运行时动态加载，最灵活，需处理 `ClassNotFoundException`|

## 反射的核心 API（java.lang.reflect 包）

| 类 / 接口            | 作用                                            |
| ----------------- | --------------------------------------------- |
| Constructor<T>    | 表示类的构造器，用于实例化对象                               |
| Method            | 表示类的方法，用于调用方法                                 |
| Field             | 表示类的字段，用于访问 / 修改字段值                           |
| Modifier          | 工具类，解析类 / 方法 / 字段的修饰符（如 public、private、final） |
| ParameterizedType | 表示泛型类型（如`List<String>`）                       |
| Annotation        | 表示注解，用于解析注解信息                                 |

## 反射的核心操作步骤

以自定义`User`类为例，演示反射的核心操作：
```java
// 目标类
public class User {
    // 字段（不同访问修饰符）
    public String username;
    private Integer age;
    // 构造器
    public User() {}
    private User(String username, Integer age) {
        this.username = username;
        this.age = age;
    }
    // 方法
    public String getUsername() {
        return username;
    }
    private void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "User{username='" + username + "', age=" + age + "}";
    }
}
```
#### 步骤 1：获取 Class 对象

```java
// 方式3：动态加载（最常用，适配配置化场景）
Class<?> cls = Class.forName("reflect_Demo.test_class");
```

> [!NOTE] 补充
> 需要处理异常 ClassNotFoundException
#### 步骤 2：操作构造器（实例化对象）
`Class`类提供以下方法获取构造器：

- `getConstructor(Class<?>... paramTypes)`：获取**public**构造器（参数为构造器参数类型的 Class 数组）；
- `getDeclaredConstructor(Class<?>... paramTypes)`：获取**任意访问修饰符**的构造器（包括 private）；
- `getConstructors()`/`getDeclaredConstructors()`：获取所有对应构造器。
```java
//调用public无参构造器  
Constructor<?> publicconstructor= cls.getConstructor();  
//使用无参构造器创建对象  
test_class user1 = (test_class)publicconstructor.newInstance(); // 等价于 new test_class()//调用private有参构造器（需打破封装）  
Constructor<?> privateconstructor= cls.getDeclaredConstructor(String.class, Integer.class);  
privateconstructor.setAccessible(true); // 破坏封装性，暴力反射  
//使用有参构造器创建对象  
test_class user2 = (test_class)privateconstructor.newInstance("Alice", 30); // 等价于 new test_class("Alice", 30)
```
#### 步骤 3：操作方法（调用方法）
`Class`类获取方法的核心方法：

- `getMethod(String name, Class<?>... paramTypes)`：获取**public**方法（包括父类继承的）；
- `getDeclaredMethod(String name, Class<?>... paramTypes)`：获取**当前类**任意访问修饰符的方法；
- `getMethods()`/`getDeclaredMethods()`：获取所有对应方法。
```Java
//调用public方法 getUsername()Method getUsernameMethod = cls.getMethod("getUsername");  
String username = (String) getUsernameMethod.invoke(user2); // 第一个参数是实例，静态方法传null  
System.out.println(username);//Alice  
//调用private方法 setAge(Integer)Method setAgeMethod = cls.getDeclaredMethod("setAge", Integer.class);  
setAgeMethod.setAccessible(true); // 跳过访问检查  
setAgeMethod.invoke(user2, 25); // 传入实例和方法参数  
System.out.println(user2); // User{username='Alice', age=25}
```
#### 步骤 4：操作字段（访问 / 修改字段值）
`Class`类获取字段的核心方法：

- `getField(String name)`：获取**public**字段（包括父类的）；
- `getDeclaredField(String name)`：获取**当前类**任意访问修饰符的字段；
- `getFields()`/`getDeclaredFields()`：获取所有对应字段。
```java
//获取public字段  
Field usernameField = cls.getField("username");  
usernameField.set(user1, "Bob"); // 给user1的username字段赋值  
System.out.println(usernameField.get(user1)); // Bob  
//修改private字段 ageField ageField = cls.getDeclaredField("age");  
ageField.setAccessible(true); // 跳过访问检查  
ageField.set(user2, 30);  
System.out.println(ageField.get(user2)); // 30
```

## 反射的高级特性

### 1.处理泛型
通过`ParameterizedType`获取泛型参数（如`List<String>`的泛型类型）：

```java
// 定义带泛型的类
class GenericClass<T> {
    private List<String> list;
}

//获取泛型字段的类型
Field listField = GenericClass.class.getDeclaredField("list");
ParameterizedType type = (ParameterizedType) listField.getGenericType();
Class<?> genericType = (Class<?>) type.getActualTypeArguments()[0];
System.out.println(genericType); // class java.lang.String
```

> [!NOTE] 对上面进行一个解析
> `Field listField = GenericClass.class.getDeclaredField("list");`
> - GenericClass.class：获取GenericClass的Class
> - getDeclaredField("list")：并获取名为`list`的字段
> 
> `ParameterizedType type = (ParameterizedType) listField.getGenericType();`
> - listField.getGenericType()：获取字段的「泛型类型」（而非原始类型 `List.class`），此处返回 `List<String>` 对应的泛型类型实例；
> - ParameterizedType：该接口专门用于表示带类型参数的泛型类型（如 `List<String>`、`Map<Integer, String>`），普通类型（如 `String`、`int`）不能转换为此接口。
> 
> `Class<?> genericType = (Class<?>) type.getActualTypeArguments()[0];`
> - `getActualTypeArguments()` ：获取泛型的「实际类型参数数组」，此处 `List<String>` 只有一个类型参数 `String`，数组索引 `0` 对应的值即为 `String.class`；如果此处是`Map<String,Integer>`,那么索引`0`对应的就是`String.class`,索引`1`对应的就是`Integer.class`
> - `Class<?>` ：得到泛型参数的具体类型对象。

### 2. 处理[Annotation（注解）](Annotation（注解）.md)
通过反射获取类 / 方法 / 字段上的注解：

```java

```

















