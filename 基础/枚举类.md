# 枚举类

用于表示**固定且有限的常量集合**（如季节、星期、颜色、状态等），相比传统的`public static final`常量定义，枚举类提供了更强的类型安全性、可读性和功能扩展性。

---

## 枚举类的基本定义与底层实现

Java 中的枚举类本质是**编译器生成的特殊 final 类**，它隐式继承`java.lang.Enum`，且所有枚举常量都是该类的`public static final`实例。

语法：

```java
enum 枚举类名 {
    枚举常量1, 枚举常量2, ..., 枚举常量n; // 枚举常量（本质是枚举类的实例）
}
```

---

## 枚举类的核心特性

1. **默认继承`java.lang.Enum`类**

   枚举类隐式继承`Enum`（因此不能再继承其他类），但可以实现接口。`Enum`类提供了基础方法（如`ordinal()`、`name()`等）。

2. **枚举常量是实例**

   每个枚举常量都是枚举类的**public static final 实例**，在枚举类加载时被创建，且不可修改。

3. **构造方法私有**

   枚举类的构造方法默认是`private`（显式声明也只能是`private`），无法通过`new`创建实例，确保枚举常量的唯一性。

4. **支持成员变量、方法和抽象方法**

   枚举类可以包含成员变量、普通方法、静态方法，甚至抽象方法（需每个枚举常量实现）。

对于这样一个枚举类：

```java
public enum Weekday {
    //枚举常量
    MONDAY("星期一",1),
    TUESDAY("星期二",2),
    WEDNESDAY("星期三",3),
    THURSDAY("星期四",4),
    FRIDAY("星期五",5),
    SATURDAY("星期六",6),
    SUNDAY("星期日",7);

    private final String name;
    private final int num;
	//构造方法
    private Weekday(String name,int num) {
        this.name = name;
        this.num = num;
    }
}
```

其通过反编译可以看出其以上特性：

```java
// 编译器生成的类继承Enum，且为final
public final class Weekday extends java.lang.Enum<Weekday> {
    // 枚举常量（静态实例）
    public static final Weekday MONDAY;
    public static final Weekday TUESDAY;
    // ... 其他常量
    
    // 编译器自动生成的values()方法（返回所有枚举常量数组）
    public static Weekday[] values();
    // 编译器自动生成的valueOf()方法（根据名称获取枚举）
    public static Weekday valueOf(java.lang.String);
    
    // 私有构造方法（由编译器生成，对应enum定义）
    private Weekday(java.lang.String, int);
    static {}; // 静态代码块初始化枚举常量
}
```

---

## 枚举类的常用方法

| 方法                   | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `name()`               | 返回枚举常量的名称（如`Weekday.MONDAY.name()`返回`"MONDAY"`） |
| `ordinal()`            | 返回枚举常量的序号（从 0 开始，按定义顺序）                  |
| `values()`             | 返回包含所有枚举常量的数组（由编译器自动生成，非`Enum`类方法） |
| `valueOf(String name)` | 根据名称获取枚举常量（名称必须匹配，否则抛`IllegalArgumentException`） |
| `toString()`           | 默认返回`name()`，可重写自定义输出                           |

实例：

```java
public class EnumTest {
    public static void main(String[] args) {
        // 获取单个枚举常量
        Weekday friday = Weekday.FRIDAY;
        System.out.println(friday.name()); // FRIDAY
        System.out.println(friday.ordinal()); // 4（从0开始）

        // 遍历所有枚举常量
        for (Weekday day : Weekday.values()) {
            System.out.println(day); // MONDAY、TUESDAY...SUNDAY
        }

        // 通过名称获取枚举常量
        Weekday monday = Weekday.valueOf("MONDAY");
        System.out.println(monday); // MONDAY
    }
}
```

---

## 枚举类的高级用法

### 1.包含构造方法与成员变量

示例看上面的`weekday`类

### 2.实现接口

枚举类虽然由于继承了`enum`类无法继承其他类，但是可以接入接口

```java
// 定义接口
interface Greeting {
    void sayHello();
}

// 枚举类实现接口
enum Gender implements Greeting {
    MALE {
        @Override
        public void sayHello() {
            System.out.println("先生你好！");
        }
    },
    FEMALE {
        @Override
        public void sayHello() {
            System.out.println("女士你好！");
        }
    };
}

// 使用
public class GenderTest {
    public static void main(String[] args) {
        Gender.MALE.sayHello(); // 先生你好！
        Gender.FEMALE.sayHello(); // 女士你好！
    }
}
```

### 3.实现单例模式

枚举是实现单例最简洁、最安全的方式 ——**天然防止反射破坏、序列化破坏**，且无需手动处理线程安全。

```java
public class SingletonEnum {
    //使用枚举类型实现单例模式
    public enum Singleton {
        INSTANCE;
        //可以添加其他方法和属性
        public void someMethod() {
            System.out.println("Singleton Enum Method Called");
        }
    }

    //全局访问点
    public static Singleton getInstance() {
        return Singleton.INSTANCE;
    }
}
```

**为什么枚举单例安全**：

- 反射无法创建枚举实例：`Constructor.newInstance()`会检查是否为枚举类，若为枚举则抛出`IllegalArgumentException`；
- 序列化安全：枚举的序列化机制特殊，反序列化时不会创建新实例，而是直接获取已存在的枚举常量。

### 4.使用专用枚举集合

Java 提供了`java.util.EnumSet`和`java.util.EnumMap`，专为枚举优化，效率远高于普通集合（底层用位运算或数组实现）。

##### （1）`EnumSet`：高效的枚举集合

```java
import java.util.EnumSet;

public class EnumSetTest {
    public static void main(String[] args) {
        // 创建包含工作日的EnumSet
        EnumSet<Weekday> workDays = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
        System.out.println(workDays); // [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY]
        
        // 创建包含休息日的EnumSet
        EnumSet<Weekday> restDays = EnumSet.of(Weekday.SATURDAY, Weekday.SUNDAY);
        System.out.println(restDays); // [SATURDAY, SUNDAY]
        
        // 判断是否包含某个枚举
        System.out.println(workDays.contains(Weekday.WEDNESDAY)); // true
    }
}
```

##### （2）`EnumMap`：键为枚举的 Map

```java
import java.util.EnumMap;
import java.util.Map;

public class EnumMapTest {
    public static void main(String[] args) {
        Map<Weekday, String> dayDesc = new EnumMap<>(Weekday.class);
        dayDesc.put(Weekday.MONDAY, "周一（打工人的开始）");
        dayDesc.put(Weekday.SUNDAY, "周日（摆烂日）");
        
        System.out.println(dayDesc.get(Weekday.MONDAY)); // 周一（打工人的开始）
        
        // 遍历EnumMap
        for (Map.Entry<Weekday, String> entry : dayDesc.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

### 5.在枚举类当中使用抽象方法

枚举类可定义抽象方法，**每个枚举常量必须实现该方法**，从而让不同常量具备差异化行为：

```java
enum Operation {
    ADD {
        @Override
        public int calculate(int a, int b) {
            return a + b;
        }
    },
    SUBTRACT {
        @Override
        public int calculate(int a, int b) {
            return a - b;
        }
    },
    MULTIPLY {
        @Override
        public int calculate(int a, int b) {
            return a * b;
        }
    },
    DIVIDE {
        @Override
        public int calculate(int a, int b) {
            if (b == 0) throw new ArithmeticException("除数不能为0");
            return a / b;
        }
    };

    // 抽象方法：每个枚举常量必须实现
    public abstract int calculate(int a, int b);
}

// 使用
public class OperationTest {
    public static void main(String[] args) {
        System.out.println(Operation.ADD.calculate(5, 3)); // 8
        System.out.println(Operation.DIVIDE.calculate(10, 2)); // 5
    }
}
```

### 6.将枚举类与注解结合

注解的属性类型可以是枚举，常用于限定注解参数的取值范围：

todo//暂时看不懂

---

## 枚举类的典型应用场景

1. **状态标识**：订单状态（`CREATED`/`PAID`/`SHIPPED`/`FINISHED`）、支付状态（`SUCCESS`/`FAIL`/`REFUND`）；
2. **配置项限定**：日志级别（`DEBUG`/`INFO`/`WARN`）、环境（`DEV`/`TEST`/`PROD`）；
3. **业务规则映射**：权限类型（`ADMIN`/`USER`/`GUEST`）、操作类型（`ADD`/`DELETE`/`UPDATE`）；
4. **单例模式**：替代传统懒汉 / 饿汉单例，更简洁安全。
