密封类是 **Java 17** 正式引入的核心特性（JEP 409），此前在 Java 15/16 中以预览特性存在。它解决了传统继承模型的痛点：`final` 类完全禁止继承（过严），普通类无限制继承（过松），密封类通过**显式指定允许继承 / 实现的子类 / 实现类**，精准控制类的扩展范围，增强代码的可维护性和类型安全性。

## 语法

使用 `sealed` 关键字修饰类 / 接口，配合 `permits` 子句列出允许的子类 / 实现类：

```java
// 密封类（抽象类，定义通用行为）
public sealed class Shape permits Circle, Rectangle, Triangle { // 仅允许这3个子类继承
    // 抽象方法：强制子类实现
    public abstract double area();
}
```

被 `permits` 列出的子类，必须显式声明以下修饰符之一，否则编译错误：

|修饰符|含义|
|---|---|
|`final`|最终子类，无法再被继承（最常用，比如 “圆形” 无需再扩展）|
|`sealed`|子类本身也是密封类，继续限制下一级继承（比如 “矩形” 仅允许 “正方形” 继承）|
|`non-sealed`|解除密封限制，允许任意类继承（作为 “密封” 和 “开放” 的中间态）|

示例：

密封类：

密封接口与其语法相同，不再赘述
```java
// 密封抽象类（同包省略 permits）
public sealed class Shape {
    public abstract double area();
}

// 1. final 子类：无法再继承
public final class Circle extends Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    @Override
    public double area() { return Math.PI * radius * radius; }
}

// 2. sealed 子类：继续限制继承（仅允许 Square 继承）
public sealed class Rectangle extends Shape permits Square {
    protected double width;
    protected double height;
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    @Override
    public double area() { return width * height; }
}

// 继承 sealed 子类的 final 子类
public final class Square extends Rectangle {
    public Square(double side) {
        super(side, side); // 调用父类构造器
    }
}

// 3. non-sealed 子类：开放继承（允许任意类继承）
public non-sealed class Triangle extends Shape {
    private double a, b, c; // 三边长度
    public Triangle(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
    @Override
    public double area() {
        double s = (a + b + c) / 2;
        return Math.sqrt(s * (s - a) * (s - b) * (s - c)); // 海伦公式
    }
}

// 合法：继承 non-sealed 的 Triangle
public class EquilateralTriangle extends Triangle {
    public EquilateralTriangle(double side) {
        super(side, side, side);
    }
}

// 非法：Shape 未允许 Hexagon 继承，编译报错
// public class Hexagon extends Shape { ... }
```

密封类配合 Java 17 引入的 **switch 模式匹配**，编译器会自动检查是否覆盖所有 `permits` 列出的子类（穷尽性检查），避免运行时遗漏分支：

```java
public class ShapeCalculator {
    public static void printArea(Shape shape) {
        // 密封类的 switch 模式匹配：编译器检查是否覆盖所有子类
        double area = switch (shape) {
            case Circle c -> c.area();       // 匹配 Circle 实例，绑定到变量 c
            case Rectangle r -> r.area();   // 匹配 Rectangle 实例
            case Triangle t -> t.area();     // 匹配 Triangle 实例
        };
        System.out.println("面积：" + area);
    }
}
```
>若遗漏某个子类（比如少写 `case Triangle t`），编译器直接报错，彻底避免传统 `switch` 的 `default` 兜底导致的逻辑漏洞。


