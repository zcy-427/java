# 泛型

Java 泛型是 JDK 5 引入的核心特性，其核心目标是**在编译期保证类型安全**，同时**消除重复代码**、**避免强制类型转换**。泛型允许在定义类、接口、方法时声明「类型参数」，使代码能适配多种数据类型，而无需为每种类型编写重复逻辑。

## 泛型的基本使用

泛型的核心是「类型参数」（Type Parameter），常用标识符：`T`（Type）、`E`（Element）、`K`（Key）、`V`（Value）、`N`（Number）等（仅为约定，可自定义）。

### 1.泛型类（Generic Class）

定义：在类名后声明类型参数，类内部可使用该参数作为属性、方法的类型。

```java
// 非泛型版本（用Object，需强制转换，类型不安全）
class noGeneric
{
    private Object content;
    public void setContent(Object content) { this.content = content; }
    public Object getContent() { return content; }
}
// 泛型版本（类型参数T，编译期检查类型）
class Generic<T>
{
    private T content;
    public void setContent(T content) { this.content = content; }
    public T getContent() { return content; }
}
public class generic_test {
    public static void main(String[] args) {
        Generic<String> test1 =new Generic<>();
        test1.setContent("Amadeus");
        String str=test1.getContent();//无强制类型转换

        Generic<Integer> test2 =new Generic<>();
        test2.setContent(123);
//        test2.setContent("abc"); //编译错误，类型检查
    }
}

```

**泛型类的实例化**：

```java
// 完整写法（JDK 7 前）：前后都指定类型
GenericBox<String> box1 = new GenericBox<String>();

// 钻石操作符（JDK 7+）：编译器自动推断右侧类型，简化写法
GenericBox<String> box2 = new GenericBox<>();

// JDK 10+：var关键字 + 钻石操作符（进一步简化）
var box3 = new GenericBox<String>();
```

### 2. 泛型接口（Generic Interface）

定义：在接口名后声明类型参数，实现类有两种方式适配：

```java
// 泛型接口
interface GenericInterface<T> {
    T process(T input);
}

// 方式1：实现时指定具体类型
class StringProcessor implements GenericInterface<String> {
    @Override
    public String process(String input) {
        return input.toUpperCase();
    }
}

// 方式2：实现时保留类型参数（成为泛型类）
class NumberProcessor<T extends Number> implements GenericInterface<T> {
    @Override
    public T process(T input) {
        return input; // 示例：直接返回数字
    }
}
```

### 3. 泛型方法（Generic Method）

定义：**独立于类的泛型**（即使类不是泛型类，也可定义泛型方法），类型参数声明在「返回值类型前」。

```java
class Generic_Method_test<T>
{
    public static <E>E genericMethod(E data)
    {
        System.out.println("Generic Method called with: " + data);
        return data;
    }
}
public class Generic_Method {
    public static void main(String[] args) {
        // 调用泛型方法，类型参数由编译器根据传入参数推断
        String str = Generic_Method_test.genericMethod("Hello, Generics!");
        Integer num = Generic_Method_test.genericMethod(100);
        Double dbl = Generic_Method_test.genericMethod(99.99);
    }
}
```

注意：

如果是静态方法，需要自己声明一个泛型参数，不要使用类的泛型参数，（因为静态成员属于类，而类的泛型参数是「实例级」的，实例化时才确定）。

> 如果上面改成作这样就会报错
>
> ```java
> class Generic_Method_test<T>
> {
>     public static T genericMethod(T data)
>     {
>         System.out.println("Generic Method called with: " + data);
>         return data;
>     }
> }
> public class Generic_Method {
>     public static void main(String[] args) {
>         // 调用泛型方法，类型参数由编译器根据传入参数推断
>         String str = Generic_Method_test.genericMethod("Hello, Generics!");
>         Integer num = Generic_Method_test.genericMethod(100);
>         Double dbl = Generic_Method_test.genericMethod(99.99);
>     }
> }
> ```
>
> 还需要注意的是，如果是这样声明的是不会报错的，因为这里的T与类的参数其实是两个不同的，但是不建议这样，还是改一改名字
>
> ```java
> public static <T>T genericMethod(T data)
> ```



## 泛型通配符（Wildcards）

Java 泛型是**不变的（invariant）** —— 即 `List<String>` 并非 `List<Object>` 的子类，即使 `String` 是 `Object` 的子类。这种严格性保证了类型安全，但也限制了灵活性。

泛型通配符表示「未知类型」，允许在不明确具体泛型类型的情况下，实现有限的类型兼容，核心用于泛型变量、方法参数 / 返回值的声明。

通配符分为无界、上界、下界三类，各自适用于不同场景，核心遵循 **PECS 原则**（后文详解）。

### 1. 无界通配符（Unbounded Wildcard）：`?`

- ✅ 只能**读取**元素（读取到的类型是 `Object`，因为未知具体类型）；
- ❌ 不能写入除 `null` 外的任何元素（因为无法确定列表实际类型，写入会破坏类型安全）；

```java
class Printer {
    public static void PrintAll(List<?> items) {
//        items.add(134); // 编译错误，不能添加任何类型的对象
        for (Object item : items) {
            System.out.println(item);
        }
    }
}
public class wildcard {
    public static void main(String[] args) {
        Printer.PrintAll(List.of("Hello", "World", 123, 45.67));
    }
}

```

### 2. 上界通配符（Upper Bounded Wildcard）：`? extends T`

这里的`？`必须是T的子类/子接口或者其本身

```java
// 计算数值集合的总和：适配Number的所有子类（Integer、Double、Long等）
public static double sum(List<? extends Number> list) {
    double total = 0.0;
    for (Number num : list) { // 读取到的元素可安全转型为Number
        total += num.doubleValue();
    }
    // list.add(10); // 编译错误：list可能是List<Double>，写入Integer会破坏类型安全
    return total;
}

// 调用：适配Integer/Double等Number子类的List
public static void main(String[] args) {
    List<Integer> intList = Arrays.asList(1, 2, 3);
    List<Double> doubleList = Arrays.asList(1.1, 2.2);
    System.out.println(sum(intList));   // 6.0
    System.out.println(sum(doubleList));// 3.3
}
```

### 3. 下界通配符（Lower Bounded Wildcard）：`? super T`

这里表示`？`必须是T的父类或者本身

```JAVA
// 向列表中添加Integer元素：适配Integer的所有父类列表（List<Number>、List<Object>）
public static void addIntegers(List<? super Integer> list) {
    list.add(10); // 合法：Integer是下界，父类列表可容纳Integer
    list.add(20);
    // Object obj = list.get(0); // 读取只能是Object类型
}

// 调用：适配Number/Object等父类的List
public static void main(String[] args) {
    List<Number> numList = new ArrayList<>();
    List<Object> objList = new ArrayList<>();
    addIntegers(numList); // 合法：Number是Integer的父类
    addIntegers(objList); // 合法：Object是Integer的父类
    System.out.println(numList); // [10, 20]
}
```

### **核心使用原则**：**PECS（Producer Extends, Consumer Super）**

| 场景             | 通配符类型    | 核心逻辑                         |
| ---------------- | ------------- | -------------------------------- |
| 生产者（只读取） | `? extends T` | 产出 T 类型的元素，用 extends    |
| 消费者（只写入） | `? super T`   | 消费 T 类型的元素，用 super      |
| 既读又写         | 不使用通配符  | 明确具体泛型类型（如 `List<T>`） |

比如JDK 集合工具类 `Collections.copy`

```java
// JDK源码中的定义：dest是消费者（写入），src是生产者（读取）
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    for (int i = 0; i < src.size(); i++) {
        dest.set(i, src.get(i)); // 安全：src读取T，dest写入T
    }
}
```

### 注意事项

1.**通配符不能用于泛型类 / 接口的声明**：

```java
class MyClass<?> {} // 编译错误：通配符不能作为类的泛型参数
interface MyInterface<? extends Number> {} // 同样错误
```

通配符仅用于**变量、方法参数 / 返回值**，泛型类 / 接口需用类型参数（如 `class MyClass<T>`）。

2.**通配符与泛型方法的区别**：

- 泛型方法（`public <T> void method(List<T> list)`）：**确定类型**（方法内 T 是明确的）；
- 通配符（`public void method(List<?> list)`）：**未知类型**（仅能以 Object 处理）；

3.**基本数据类型不能作为通配符的边界**

```java
List<? extends int> list; // 编译错误：int是基本类型，需用包装类Integer
List<? extends Integer> list; // 合法
```

4.**多边界泛型类**

当有多个边界时，需要使用`&`连接，且类边界必须放在第一个（且只能有一个类边界），接口边界无数量限制。

```java
class RestrictedBox<T extends Number & Comparable<T> & java.io.Serializable>
```

---

## 泛型类的继承与实现

### 1. 泛型类继承泛型类

```java
// 父泛型类
class Parent<T> {
    private T data;
    public T getData() { return data; }
}

// 子类1：指定父类的类型参数为具体类型
class Child1 extends Parent<String> {
    // 父类的T被固定为String
    public void print() {
        String str = getData(); // 直接获取String类型
    }
}

// 子类2：保留父类的类型参数（子类也成为泛型类）
class Child2<T> extends Parent<T> {
    // 父类的T与子类的T一致
    public void setData(T data) {
        // 若父类有setter，可直接使用
    }
}

// 子类3：重新声明类型参数（可指定边界）
class Child3<T extends Number> extends Parent<T> {
    // 父类的T被限制为Number子类
}
```

2.**泛型类实现泛型接口**

```java
interface GenericInterface<T> {
    T process(T input);
}

// 泛型类实现泛型接口（类型参数一致）
class Processor<T> implements GenericInterface<T> {
    @Override
    public T process(T input) {
        return input;
    }
}

// 泛型类实现泛型接口（指定具体类型）
class StringProcessor implements GenericInterface<String> {
    @Override
    public String process(String input) {
        return input.toUpperCase();
    }
}
```

---

## 泛型类的底层：类型擦除（Type Erasure）

Java 泛型是「编译期特性」——JVM 运行时**无泛型信息**，所有泛型类都会被「擦除」为原始类型（Raw Type），这是理解泛型类限制的核心。

###  类型擦除的具体过程

| 泛型类声明                    | 擦除后原始类型 | 关键操作                    |
| ----------------------------- | -------------- | --------------------------- |
| `class Box<T>`                | `class Box`    | T 被替换为 `Object`         |
| `class Box<T extends Number>` | `class Box`    | T 被替换为边界类型 `Number` |
| `class Pair<K, V>`            | `class Pair`   | K/V 均替换为 `Object`       |

示例：擦除前后的代码对比

```java
// 擦除前（源码）
class GenericBox<T> {
    private T content;
    public T getContent() { return content; }
    public void setContent(T content) { this.content = content; }
}

// 擦除后（JVM 实际执行的代码）
class GenericBox {
    private Object content;
    public Object getContent() { return content; }
    public void setContent(Object content) { this.content = content; }
}
```

### 桥接方法（Bridge Method）：解决擦除后的多态冲突

```java
// 泛型接口
interface GenericInterface<T> {
    T process(T input);
}

// 实现类
class StringProcessor implements GenericInterface<String> {
    @Override
    public String process(String input) {
        return input.toUpperCase();
    }
}
```

在类型擦除后,接口的 `process(T)` 变为 `process(Object)`，但实现类的 `process(String)` 无法重写 `process(Object)`，因此编译器自动生成桥接方法：

```java
// 编译器自动生成的桥接方法（字节码层面）
public Object process(Object input) {
    // 调用实际的process(String)方法
    return process((String) input); 
}
```

---

## 注意事项

1.**类型的参数不能是基本数据类型**

泛型类的类型参数基于 `Object`（类型擦除后），而基本数据类型（`int`、`char`、`double` 等）不继承 `Object`，因此必须使用包装类：

2.**静态方法不能使用类的类型参数**

泛型类的类型参数是「实例级」的（实例化时才确定），而静态成员属于类，因此静态成员无法直接使用类的类型参数

3.**不能实例化类型参数的对象或者数组**

类型擦除后，JVM 无法确定 `T` 的具体类型，因此不能直接 `new T()` 或 `new T[]`：

4.**泛型类不能继承 `Throwable`**

泛型类无法作为异常类（不能继承 `Exception`、`RuntimeException`、`Error` 等），因为异常处理在运行时，而泛型类型擦除后无法区分具体类型：

5.**类型擦除后泛型类的类型相等性误解**

```java
Box<String> stringBox = new Box<>();
Box<Integer> intBox = new Box<>();
// 输出：true（两个对象的类是同一个）
System.out.println(stringBox.getClass() == intBox.getClass()); 
```

