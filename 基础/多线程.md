# 多线程

允许程序在同一进程内同时执行多个独立的任务（线程），这些线程共享进程的内存空间（如堆、方法区），但拥有各自的栈空间和程序计数器，从而提高程序的执行效率和资源利用率。

---

### 一些核心概念

- **进程**：操作系统分配资源的基本单位（如内存、CPU 时间片），一个进程包含至少一个线程。
- **线程**：CPU 调度的基本单位，是进程内的执行流，线程间切换开销远小于进程。
- **并发 vs 并行**：并发是 “交替执行”（单核 CPU 下多线程切换），并行是 “同时执行”（多核 CPU 下多线程真正并行）。

### java实现多线程的方法

#### 1.继承Thread类

`Thread` 类是 Java 线程的基类，继承后需重写 `run()` 方法（线程执行体），通过 `start()` 方法启动线程（而非直接调用 `run()`）。

```java
class MyThread extends Thread{
    @Override
    public void run()
    {
        System.out.println("This is a Thread");
    }
}
public class Threads {
    public static void main(String[] args) {
        MyThread t=new MyThread();
        t.start(); // 启动线程，JVM 调用 run()
    }
}
```

#### 2.实现Runnable接口

`Runnable` 是函数式接口（仅 `run()` 方法），实现后需将实例传入 `Thread` 构造器启动。

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行：" + Thread.currentThread().getName());
    }
}

public class Test {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
        
        // 简化：Lambda 表达式（Runnable 是函数式接口）
        new Thread(() -> System.out.println("Lambda 线程")).start();
    }
}
```

#### 3. 实现 `Callable` 接口 + `FutureTask`

`Callable` 支持**返回值**和**抛出异常**，需配合 `FutureTask`（接收 `Callable` 结果）使用。

```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) sum += i;
        return sum;
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());
        new Thread(futureTask).start();
        
        Integer result = futureTask.get(); // 阻塞获取返回值
        System.out.println("计算结果：" + result); // 输出 5050
    }
}
```

#### 4.线程池

直接使用提前创建好的线程，且执行完的线程没有被销毁，提高了资源复用率

---

### 线程的生命周期

Java 线程有 **6 种状态**（`Thread.State` 枚举），状态转换如下：

1. **新建（New）**：创建 `Thread` 对象但未调用 `start()`。
2. **就绪（Runnable）**：调用 `start()` 后，线程等待 CPU 调度（未获取执行权）。
3. **运行（Running）**：线程获取 CPU 执行权，执行 `run()`。
4. **阻塞（Blocked）**：线程等待获取锁（如 `synchronized` 未抢到锁）。
5. **等待（Waiting）**：线程无时限等待（如 `wait()`、`join()` 无参），需其他线程唤醒。
6. **超时等待（Timed Waiting）**：线程有时限等待（如 `sleep(1000)`、`wait(1000)`）。
7. **终止（Terminated）**：`run()` 执行完毕或线程异常终止。

```java
public class Threadstate {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        },"Amadeus");
        System.out.println("before start：" + thread.getState().name());
        thread.start();
        System.out.println("after start：" + thread.getState().name());

        Thread.State prestate=null;
        while(thread.isAlive())
        {
            Thread.State curstate=thread.getState();
            if(curstate!=prestate) {
                System.out.println("state：" + curstate.name());
                prestate = curstate;
            }
        }
    }
}

```

### 线程的常用方法

| 方法                | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| `start()`           | 启动线程，使线程进入就绪状态（由 JVM 调度执行 `run()`）。    |
| `run()`             | 线程执行体，直接调用仅为普通方法，不启动新线程。             |
| `sleep(long ms)`    | 让线程休眠指定毫秒，**不释放锁**，休眠后回到就绪状态。       |
| `join()`/`join(ms)` | 等待线程终止（或等待指定毫秒），常用于主线程等待子线程完成。 |
| `yield()`           | 线程主动让出 CPU 执行权，回到就绪状态（可能立即被调度）。    |
| `wait()`/`notify()` | 用于线程间通信，`wait()` 释放锁并进入等待池，`notify()` 唤醒等待线程。 |
| `interrupt()`       | 中断线程（设置中断标志），需配合 `isInterrupted()` 检测。    |
| `setDaemon(true)`   | 设置为守护线程（如 GC 线程），主线程结束后守护线程自动终止。 |

 这里重点说一下`setDaemon`和`interrupt`

`setDaemon`这个方法将会把当前线程设置为**守护线程**，这里需要知道，线程可以分为**用户线程与守护线程**，用户线程主要用于**处理业务逻辑**，而守护线程主要用于**垃圾回收，监控日志**，其需要一直在后台运行，当所有的用户线程都结束时，及时守护线程还在运行，JVM依旧会退出并且结束所有的守护线程

```java
public class DaemonThread {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("用户线程执行完毕");
        }, "DaemonThread");
        thread.setDaemon(true);
        thread.start();
        System.out.println("主线程执行完毕");
    }
}

```

这里将不会打印 `用户线程执行完毕`，因为主线程已经结束，`thread`作为守护线程将直接结束

对于`interrupt`

```java
public class interrupt_demon {
    public static void main(String[] args) {
        Thread countThread = new Thread(() -> {
           long count = 0;
           while(!Thread.currentThread().isInterrupt ed())
           {
               count++;
               if(count%100000==0)
               {
                   System.out.print("\rcount="+count);
               }
           }

        }, "InterruptibleThread");
        countThread.start();

        Thread interruptThread =new Thread(()->{
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("\nInterrupting "+countThread.getName()+" ...");
            countThread.interrupt();
        },"InterruptThread");
        interruptThread.start();
    }
}
```

在上面这段代码中`countThread`将会一直增加`count`，直到`interruptThread`发出中断信号，没错，**这只是一个信号，是否中断取决于线程自己**

---

### 线程安全与同步机制

对于多线程，往往会出现数据竞争，这时就需要同步机制保证线程安全

#### synchronized 关键字

`synchronized` 可修饰**实例方法**、**静态方法**或**代码块**，不同修饰方式对应不同的**锁对象**。

1.**修饰实例对象**

- **锁对象**：当前实例对象（`this`）。
- **效果**：多个线程调用**同一个实例**的该方法时会互斥；调用**不同实例**的该方法时不会互斥（因为锁对象不同）。

```java
class Counter {
    private int count = 0;

    // 同步实例方法：锁是 this（Counter 实例）
    public synchronized void increment() {
        count++; // 原子操作（同步块内）
        System.out.println(Thread.currentThread().getName() + ": " + count);
    }
}

public class Test {
    public static void main(String[] args) {
        Counter counter = new Counter(); // 同一个实例

        // 两个线程调用同一个实例的 increment()，会互斥
        new Thread(counter::increment, "线程1").start();
        new Thread(counter::increment, "线程2").start();
    }
}
```

2.**修饰静态方法**

- **锁对象**：当前类的 `Class` 对象（如 `Counter.class`）。
- **效果**：所有线程调用该静态方法时都会互斥（无论是否是同一个实例，因为锁是类对象，全局唯一）。

```java
class Counter {
    private static int staticCount = 0;

    // 同步静态方法：锁是 Counter.class
    public static synchronized void staticIncrement() {
        staticCount++;
        System.out.println(Thread.currentThread().getName() + ": " + staticCount);
    }
}

public class Test {
    public static void main(String[] args) {
        // 两个线程调用静态方法，即使是不同实例，也会互斥
        new Thread(Counter::staticIncrement, "线程1").start();
        new Thread(Counter::staticIncrement, "线程2").start();
    }
}
```

3.**修饰代码块**

- **锁对象**：显式指定的任意引用类型对象（如 `this`、类对象、自定义锁对象）。
- **优势**：粒度更细（仅同步关键代码），避免整个方法同步的性能开销。

```java
class Counter {
    private int count = 0;
    private final Object lock = new Object(); // 自定义锁对象（推荐用final，避免锁对象被修改）

    public void increment() {
        // 同步代码块：锁是 lock 对象
        synchronized (lock) {
            count++;
            System.out.println(Thread.currentThread().getName() + ": " + count);
        }
    }
}
```

**常见锁对象选择**：

- `synchronized (this)`：等价于同步实例方法（锁当前实例）。
- `synchronized (Counter.class)`：等价于同步静态方法（锁类对象）。
- 自定义 `final Object lock`：避免锁与实例 / 类绑定，灵活性更高。

**注意：**

**避免锁对象被修改**：锁对象若被重新赋值（如 `lock = new Object()`），会导致后续线程使用新锁，失去同步效果。
**锁对象必须是引用类型**：不能用基本类型（如 `int`、`long`），因为基本类型不是对象，无法关联 Monitor。
**避免使用 String 常量 / 包装类作为锁**：String 常量池会导致不同地方的字符串对象指向同一实例，可能意外共享锁；包装类（如 `Integer`）的缓存机制也会导致类似问题。

---

#### lock显式锁

`Lock` 接口的常用实现类有 `ReentrantLock`（可重入锁）、`ReentrantReadWriteLock`（读写锁）和 `StampedLock`（Java 8 新增），其中 `ReentrantLock` 是最基础、最常用的实现。

##### **1. `ReentrantLock`（可重入独占锁）**

`ReentrantLock` 是**可重入锁**（同一线程可重复获取同一把锁），也是**独占锁**（同一时刻只有一个线程能持有锁），支持**公平锁**和**非公平锁**两种模式。

**基本的使用方式**：

必须在 `try` 块中加锁，`finally` 块中释放锁，确保锁一定会被释放：

```java
import java.util.concurrent.locks.ReentrantLock;

class R_test
{
    private int num=0;
    private final ReentrantLock lock=new ReentrantLock();//默认非公平锁
    public void increase()
    {
        lock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+":"+num);
            num++;
        } finally {
            lock.unlock();//必须在finally中释放锁
        }
    }
}
public class ReentrantLock_test {
    public static void main(String[] args) {
        R_test r=new R_test();
        for(int i=0;i<5;++i)
        {
            new Thread(r::increase,"线程"+i).start();
        }
    }
}
```

**公平锁与非公平锁**

- **非公平锁**（默认）：`new ReentrantLock(false)`，线程获取锁时不遵循等待顺序，直接尝试抢占，性能更高（避免线程切换开销），但可能导致部分线程长期等待（“饥饿”）。
- **公平锁**：`new ReentrantLock(true)`，线程按等待队列的顺序获取锁，避免 “饥饿”，但性能较低（需维护等待队列）。

```java
ReentrantLock fairLock = new ReentrantLock(true); // 公平锁
```

**可中断获取锁**

通过 `lockInterruptibly()` 实现，线程在等待锁时可响应中断：	

```java
public void testInterruptibleLock() throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    Thread t1 = new Thread(() -> {
        try {
            lock.lockInterruptibly(); // 可中断获取锁
            try {
                Thread.sleep(1000); // 持有锁1秒
            } finally {
                lock.unlock();
            }
        } catch (InterruptedException e) {
            System.out.println("线程被中断，放弃获取锁");
        }
    });
    t1.start();
    Thread.sleep(100);
    t1.interrupt(); // 中断线程t1
}
```

**超时获取锁**

通过 `tryLock(long time, TimeUnit unit)` 实现，超时未获取锁则放弃，避免死锁：

##### 2. `ReentrantReadWriteLock`（读写锁）

`ReentrantReadWriteLock` 是**读写分离锁**，将锁分为**读锁**（共享锁）和**写锁**（独占锁），适用于**读多写少**的场景（如缓存、配置读取），能大幅提升并发性能。

**核心规则：**

- **读锁**：多个线程可同时持有读锁（共享），但写锁被持有期间，读锁无法获取。
- **写锁**：同一时刻只有一个线程能持有写锁（独占），写锁被持有期间，读锁和其他写锁都无法获取。

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

class rwlock_test
{
    private final ReentrantReadWriteLock  rwlock=new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.ReadLock readLock=rwlock.readLock();
    private final ReentrantReadWriteLock.WriteLock writeLock=rwlock.writeLock();
    private String Data="default";
    public void get()
    {
        readLock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+"：读取到数据："+Data);
        } finally {
            readLock.unlock();
        }
    }

    public void put(String data)
    {
        writeLock.lock();
        try{
            Data=data;
            System.out.println(Thread.currentThread().getName()+"：写入数据："+Data);
        } finally {
            writeLock.unlock();
        }
    }
}
public class rwlcok {
    public static void main(String[] args) {
        rwlock_test rw=new rwlock_test();
        new Thread(rw::get,"读线程1").start();
        new Thread(rw::get,"读线程2").start();
        new Thread(()->rw.put("新数据"),"写线程1").start();
    }
}
```

##### 3. `StampedLock`（Java 8 新增）

`StampedLock` 是对读写锁的进一步优化，支持**乐观读**模式，在几乎无写操作的场景下，性能比 `ReentrantReadWriteLock` 更高。它的核心特点是：

- 获取锁时会返回一个**戳记（stamp）**，释放锁时需传入该戳记；
- 支持**乐观读**：无需获取读锁，直接读取数据，读取后验证是否有写操作发生，若未发生则直接使用数据，否则升级为读锁重新读取。

```JAVA
import java.util.concurrent.locks.StampedLock;

class StampedLock_test
{
    private StampedLock lock=new StampedLock();
    private String Data="default";

    public void write(String data)
    {
        long stamp=lock.writeLock();
        try{
            Data=data;
            System.out.println(Thread.currentThread().getName()+"：写入数据："+Data);
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    public String read()
    {
        //乐观读，返回戳记
        long stamp=lock.tryOptimisticRead();
        String temp=Data;//乐观读数据
        if(!lock.validate(stamp))//验证戳记是否有效
        {
            //戳记无效，获取读锁
            stamp=lock.readLock();
            try{
                temp=Data;//悲观读数据
            } finally {
                lock.unlockRead(stamp);
            }
        }
        return temp;
    }
}
```

---

##### 条件变量

- 它与 `Lock` 绑定，通过 `Lock.newCondition()` 创建，**必须在锁的保护下使用**；
- 每个 `Condition` 对应一个**条件队列**，线程调用 `await()` 会进入该队列等待，调用 `signal()` 会唤醒队列中的线程；
- 支持**多个条件队列**，解决了 `synchronized` 中仅能有一个等待队列的限制。

**核心方法**

| 方法分类         | 方法签名                                                     | 作用                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **基础等待**     | `void await() throws InterruptedException`                   | 使当前线程进入条件队列等待，**释放持有的锁**；线程被唤醒或中断时抛出 `InterruptedException` 并返回，重新获取锁后继续执行。 |
| **超时等待**     | `boolean await(long time, TimeUnit unit) throws InterruptedException` | 限时等待：若在指定时间内条件满足则返回 `true`，超时则返回 `false`；期间释放锁，被中断时抛出异常。 |
| **无中断等待**   | `void awaitUninterruptibly()`                                | 进入条件队列等待，**不响应线程中断**，直到被唤醒；期间释放锁，唤醒后重新获取锁。 |
| **绝对时间等待** | `long awaitNanos(long nanosTimeout) throws InterruptedException` | 以纳秒为单位的超时等待，返回剩余的超时时间（若超时则返回负数）。 |
| **唤醒单个线程** | `void signal()`                                              | 唤醒条件队列中**等待时间最长的一个线程**（FIFO）；被唤醒的线程不会立即执行，需重新获取锁后才能继续。 |
| **唤醒所有线程** | `void signalAll()`                                           | 唤醒条件队列中的**所有等待线程**；所有被唤醒的线程会竞争锁，获取到锁的线程才能继续执行。 |

**使用步骤**

1.创建lock变量

2.调用lock的`newcondition`方法创建condition变量

3.在调用完`lock.lock`后调用condition的方法

4.最后在finally中调用`lock.unlock`

示例：

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class conditiondemo {
    private final ReentrantLock lock=new ReentrantLock();
    private final Condition cv=lock.newCondition();
    boolean flag=false;
    public void await()
    {
        lock.lock();
        try{
            while(!flag){
                System.out.println(Thread.currentThread().getName()+" is waiting");
                cv.await();
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }finally {
            lock.unlock();
        }
    }

    public void awake()
    {
        lock.lock();
        try{
            flag=true;
            System.out.println(Thread.currentThread().getName()+" is awake");
            cv.signal();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        conditiondemo demo=new conditiondemo();
        new Thread(demo::await,"等待线程").start();
        Thread.sleep(5000);
        demo.awake();
    }
}
```

**典型应用**：生产者消费者模型

`Condition` 的最大优势是**支持多个条件队列**，可分别管理 “生产者等待队列未满” 和 “消费者等待队列非空” 两个条件，比 `synchronized` 的 `wait()`/`notify()` 更精准。

```java
	import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerConsumer {
    private final ReentrantLock lock=new ReentrantLock();
    private final Condition ProductCondition=lock.newCondition();
    private final Condition ConsumeCondition=lock.newCondition();
    private final Queue<Integer> queue=new LinkedList<>();
    private final int CAPACITY=5;

    public void Produce(int value) throws InterruptedException {
        lock.lock();
        try{
            while(queue.size()==CAPACITY)
            {
                System.out.println("生产队列已满，等待消费");
                ProductCondition.await();
            }
            queue.offer(value);
            System.out.println("生产者生产了:"+value);
            ConsumeCondition.signal();//唤醒消费者
        }finally {
            lock.unlock();
        }
    }

    public void Consume() throws InterruptedException {
        lock.lock();
        try{
            while(queue.isEmpty())
            {
                System.out.println("队列为空，等待生产");
                ConsumeCondition.await();
            }
            int num=queue.poll();
            System.out.println("消费者消费了"+num);
            ProductCondition.signal();//唤醒生产者
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ProducerConsumer pc=new ProducerConsumer();
        Thread producer=new Thread(()->{
            for(int i=0;i<10;++i)
            {
                try {
                    pc.Produce(i);
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        Thread consumer=new Thread(()->{
            for(int i=0;i<10;++i)
            {
                try {
                    pc.Consume();
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        producer.start();
        consumer.start();
    }
}
```

