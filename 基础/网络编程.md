Java 网络编程是基于**TCP/IP 协议栈**封装底层通信细节，提供易用的 API 实现跨主机数据交互的技术，核心是**Socket（套接字）** —— 网络通信的端点（由 IP 地址 + 端口号唯一标识）。本文从基础概念、核心 API、编程模型、高级特性到实战重点全面讲解，标注所有核心重点。

## 基础概念

### 软件架构

#### **C/S(客户端 - 服务器架构)**

将系统拆分为**客户端（Client）和服务器（Server）** 两部分，通过网络通信交互：

客户端：负责用户交互（如桌面 APP、手机 APP），处理部分本地逻辑（如数据缓存、UI 渲染）；
服务器：负责核心业务处理、数据存储（如数据库服务器、应用服务器），为多个客户端提供服务。

```plaintext
客户端（PC/手机APP） ←→ 服务器（应用服务器 + 数据库服务器）
```

- 通信方式：TCP/UDP 协议（如 Socket）、HTTP 协议（如 REST API）。

其性能好，交互体验佳，适用于对交互体验和性能要求高的场景（如游戏、办公软件、金融 APP）。比如各种手机APP

#### **B/S(浏览器 - 服务器架构)**

C/S 架构的简化版，**客户端统一为浏览器**（如 Chrome、Edge），服务器负责所有业务逻辑和数据存储，用户通过浏览器访问系统（无需安装额外客户端）。

```plaintext
浏览器（用户） ←→ Web服务器（如Nginx） ←→ 应用服务器（如Tomcat） ←→ 数据库服务器
```

- 通信方式：HTTP/HTTPS 协议（如 REST API、HTML 渲染）。

其方便访问，无需安装客户端，维护成本低，适用于互联网应用、企业 Web 系统（如电商网站、在线教育平台、OA 系统）。比如各种网页版应用


### 协议+IP地址+端口

这里我们可以把用户访问服务器的过程比作从自己家去到别人家，这里的**协议**相当于交通工具（汽车/飞机等），**IP地址**相当于别人家的住在哪一个街道（xxxx路xxx街），而**端口**相当于门牌号

其本质是**IP地址**用于标识“网络中的路由节点 / 设备”，而**端口**用于标识 “设备上的程序通道”

协议我们后面再说，总之我们通过**协议+IP地址+端口**的这样的一个组合，我们就可以精准的访问到特定服务器上的一个特定服务程序。

#### IP的分类

##### **IPv4**

IPv4 地址是 32 位二进制数（如`11000000.10101000.00000001.00000001`），通常转换为 **点分十进制（Dotted Decimal）** 表示（如`192.168.1.1`）其按照 **前几位二进制（网络位前缀）** 划分 A-E 类

| 类别  | 网络位（前 n 位）        | 主机位     | 点分十进制地址范围                   | 默认子网掩码        | 可分配主机数（理论）         | 适用场景             |
| --- | ----------------- | ------- | --------------------------- | ------------- | ------------------ | ---------------- |
| A 类 | 8 位（前 1 位 = 0）    | 24 位    | 1.0.0.0 ~ 126.255.255.255   | 255.0.0.0     | 2²⁴ - 2 = 16777214 | 大型网络（如跨国企业、运营商）  |
| B 类 | 16 位（前 2 位 = 10）  | 16 位    | 128.0.0.0 ~ 191.255.255.255 | 255.255.0.0   | 2¹⁶ - 2 = 65534    | 中型网络（如学校、中型企业）   |
| C 类 | 24 位（前 3 位 = 110） | 8 位     | 192.0.0.0 ~ 223.255.255.255 | 255.255.255.0 | 2⁸ - 2 = 254       | 小型网络（如家庭、办公室局域网） |
| D 类 | 前 4 位 = 1110      | 无（组播地址） | 224.0.0.0 ~ 239.255.255.255 | 无默认子网掩码       | 无（不分配给主机）          | 组播通信（如视频会议、直播）   |
| E 类 | 前 4 位 = 1111      | 无（保留地址） | 240.0.0.0 ~ 255.255.255.255 | 无默认子网掩码       | 无（不分配给主机）          | 科研、实验用途（未公开使用）   |
这里**可分配主机数减2的原因**是：每个网段中，**网络地址（主机位全 0）** 和 **广播地址（主机位全 1）** 是特殊地址，不能分配给具体设备（如电脑、手机）。
##### **子网掩码的作用**

子网掩码的二进制结构遵循 “全 1 对应网络位，全 0 对应主机位” 的规则：

- 二进制中 “1” 的部分：标识 IP 地址的 **网络位**（代表设备所在的 “网段”）；
- 二进制中 “0” 的部分：标识 IP 地址的 **主机位**（代表网段内的 “具体设备”）。

把 IP 地址比作一块 “32 格的蛋糕”：

- 子网掩码的 “1”= 蛋糕的 “公共部分”（代表网段，所有人共享）；
- 子网掩码的 “0”= 蛋糕的 “私有部分”（代表设备，每个设备独占）；
- 不同的子网掩码，就是 “切蛋糕的方式不同”—— 切的 “公共部分” 越多（1 越多），“私有部分” 越少（0 越少），网段内可容纳的设备就越少；反之则设备越多。

子网掩码**常用于判断两台设备是否在 “同一网段”（能否直接通信）**，局域网内的设备，只有在**同一网段**才能直接通信（无需路由器转发）；不同网段的设备，必须通过路由器转发才能通信。

- 对两台设备的 IP 地址，分别和子网掩码进行 **二进制与运算**；
- 若运算结果（即 “网络地址”）相同 → 同一网段，可直接通信；
- 若结果不同 → 不同网段，需路由器转发

再就是**用于子网划分（解决 IP 地址浪费问题）**，避免大网段的 IP 浪费，适配不同规模的子网络（如公司的不同部门、学校的不同院系）；

##### IPv4的特殊地址

1.私有 IP 地址（局域网专用，不可公网访问）

2.公网 IP 地址（互联网全局唯一）

3.广播地址（网段内全员接收）

4.0.0.0.0（任意地址）

5.127.0.0.1(本地回环地址)

##### IPv6

IPv4 地址仅 32 位，总数量约 43 亿，已耗尽，因此 IPv6（128 位）成为下一代 IP 协议，地址数量约`2¹²⁸`（足够全球设备使用）。

| 分类   | 前缀（前 n 位）          | 地址范围                   | 适用场景                                       |
| ---- | ------------------ | ---------------------- | ------------------------------------------ |
| 单播地址 | 001（全球单播）          | 2000::/3 ~ 3fff:ffff/3 | 类似 IPv4 公网 IP，全球唯一，用于设备间点对点通信              |
|      | 1111111010（链路本地单播） | fe80::/10              | 类似 IPv4 私有 IP，仅在同一链路（局域网）内使用，自动分配          |
| 组播地址 | 11111111（ff00::/8） | ff00::/8 ~ ffff::/8    | 类似 IPv4 D 类地址，用于组播通信（如视频会议）                |
| 任播地址 | 与单播地址前缀相同          | 同单播地址范围                | 发送到任播地址的数据，由 “最近的一个目标设备” 接收（如 DNS 服务器负载均衡） |

##### 域名

可以 **互联网中用于标识主机（服务器 / 设备）的人性化字符串**，核心作用是替代难记的 IP 地址（如`180.101.49.11`），让用户通过易读易记的名称（如`www.baidu.com`）访问网络服务

结构拆解（以`www.baidu.com`为例）

| 层级        | 名称        | 示例值     | 作用说明                                                  |
| --------- | --------- | ------- | ----------------------------------------------------- |
| 第 1 层（最左） | 主机名（Host） | `mail`  | 标识服务器上的具体服务（如`mail`= 邮件服务，`www`=Web 服务，`ftp`= 文件传输服务） |
| 第 2 层     | 二级域名（SLD） | `baidu` | 核心域名，通常是机构 / 企业的名称（如`baidu`= 百度，`github`=GitHub）      |
| 第 3 层（最右） | 顶级域名（TLD） | `com`   | 域名的最高层级，标识域名类型（如`com`= 商业机构，`cn`= 中国地区）               |

**DNS解析：域名->IP** 

* [ ] DNS详解
---
#### 端口

 端口是 **传输层协议（TCP/UDP）** 中的概念，用 16 位无符号整数表示，范围是 `0~65535`（共 65536 个端口）；
 
 一台设备（如电脑、服务器）可能同时运行多个网络程序（如浏览器、微信、本地 Tomcat 服务器、MySQL 数据库）；IP 地址仅能定位到设备，而端口能精准定位到设备上的某个网络程序

端口仅在 **单台设备内部** 唯一，不具备跨设备唯一性（例如：设备 A 的 8080 端口和设备 B 的 8080 端口是独立的，互不冲突）。

端口按用途分为 **知名端口、注册端口、动态 / 私有端口** 三类，范围和用途明确，是开发和部署的基础规范：

|分类|端口范围|核心用途|关键注意事项|
|---|---|---|---|
|知名端口（Well-Known Ports）|0~1023|系统 / 常用网络服务的默认端口（由 IANA（互联网号码分配局）统一分配管理）|1. 普通用户程序不建议使用（需管理员权限）；<br><br>2. 避免占用已分配的知名端口（如 80、443、3306）|
|注册端口（Registered Ports）|1024~49151|用户自定义网络服务、应用程序的常用端口（可向 IANA 注册，避免冲突）|1. 开发中优先选择此范围端口；<br><br>2. 需提前确认端口未被其他常用程序占用（如 8080、9090）|
|动态 / 私有端口（Dynamic/Private Ports）|49152~65535|客户端程序临时使用的端口（由操作系统自动分配，用完释放）|1. 不建议手动绑定此范围端口（可能被系统征用）；<br><br>2. 客户端 Socket 无需手动指定，由系统随机分配|
- [ ] 端口在编程方面的东西

---
#### 协议

##### TCP

TCP（Transmission Control Protocol）是一种**面向连接、可靠、基于字节流**的传输层协议，通过一系列机制（三次握手、确认重传、流量控制、拥塞控制）保证数据 “无丢失、无重复、按序到达”，是互联网中最常用的协议（如 HTTP/HTTPS、FTP、SSH 等均基于 TCP）。**但是牺牲部分实时性和效率**。适用于文件传输 、支付交易、网页加载等数据不能够丢失的场景。

- [ ] TCP协议的一些具体细节🛫 2025-12-08 

##### UDP

UDP（User Datagram Protocol）是一种**无连接、不可靠、基于数据报**的传输层协议，仅提供 “尽最大努力交付” 的服务（即发送方只管发送，不关心接收方是否收到，**也不处理丢包、重传**）。**追求 “快速、轻量化、低延迟”**，适用于要求实时性的场景(如视频通话、游戏、直播），或数据量小且允许丢包的场景（如 DNS 查询、DHCP 分配 IP）。

- [ ] UDP协议的一些具体细节🛫 2025-12-08 

---
## Java.net核心API


###  InetAddress（IP 地址封装）

表示 IP 地址，封装 IP 与主机名的映射关系，无构造方法，通过静态方法创建。

| 核心方法                                        | 作用                                               |
| ------------------------------------------- | ------------------------------------------------ |
| `static InetAddress getByName(String host)` | 通过域名 / IP 字符串获取 IP 对象（如`getByName("localhost")`） |
| `static InetAddress getLocalHost()`         | 获取本机 IP 地址                                       |
| `String getHostAddress()`                   | 获取 IP 字符串（如`127.0.0.1`）                          |
| `String getHostName()`                      | 获取主机名                                            |
| `boolean isReachable(int timeout)`          | 检测是否可达（ping）                                     |

```java
import java.io.IOException;  
import java.net.InetAddress;  
import java.net.UnknownHostException;  
  
public class InetAddressdemo {  
    public static void main(String[] args) {  
        try{  
            InetAddress localhost=InetAddress.getLocalHost();  
            System.out.println("本地主机名："+localhost.getHostName());  
            System.out.println("本地主机地址："+localhost.getHostAddress());  
            InetAddress bilibili=InetAddress.getByName("www.bilibili.com");  
            boolean IsReachable= bilibili.isReachable(1000);  
            System.out.println(IsReachable);  
        }catch (UnknownHostException e)  
        {  
            System.err.println("无法获取本地主机地址："+e.getMessage());  
        }  
        catch (IOException e)  
        {  
            System.out.println("网络异常："+e.getMessage());  
        }  
    }  
}
```

### Socket(TCP 客户端套接字)

客户端发起 TCP 连接，与服务端双向通信，核心是获取输入 / 输出流。

**核心构造方法**

|构造方法|说明|
|---|---|
|`Socket(String host, int port)`|直接连接指定主机 + 端口|
|`Socket(InetAddress addr, int port)`|通过 IP 对象连接|
|`Socket()`|无参构造（后续通过`connect()`手动连接）|

#### 核心方法

| 方法                                                  | 作用             | 重点                                |
| --------------------------------------------------- | -------------- | --------------------------------- |
| `InputStream getInputStream()`                      | 获取输入流（读服务端数据）  | 需关闭，避免泄漏                          |
| `OutputStream getOutputStream()`                    | 获取输出流（写数据到服务端） | 建议用缓冲流包装                          |
| `void connect(SocketAddress endpoint, int timeout)` | 手动连接，设置超时时间    | 避免无限阻塞                            |
| `void setSoTimeout(int timeout)`                    | 设置读取超时（毫秒）     | 防止`read()`无限阻塞                    |
| `void close()`                                      | 关闭套接字（释放资源）    | 必须在 finally/try-with-resources 中执 |
示例(实现一个TCP客户端)：

```Java
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.Socket;  
import java.net.UnknownHostException;  
  
public class TCPClient {  
    public static void main(String[] args) {  
        String serverAddress="localhost";//服务器地址  
        int port=8080;//服务器端口号  
        try(java.net.Socket socket=new Socket(serverAddress,port);  
            //读取服务器数据  
            BufferedReader in=new BufferedReader(new java.io.InputStreamReader(socket.getInputStream()));  
            //发送数据到服务器  
            PrintWriter out=new PrintWriter(socket.getOutputStream(),true);  
            //创建键盘输入  
            BufferedReader userInput=new BufferedReader(new InputStreamReader(System.in))  
            )  
        {  
            System.out.println("已连接到服务器："+serverAddress+":"+port);  
            System.out.print("请输入要发送的消息：");  
            String message=userInput.readLine();//读取用户输入  
            //发送消息到服务器  
            out.println(message);  
            //读取服务器响应  
            String response=in.readLine();  
            System.out.println("收到服务器响应："+response);  
        }catch (UnknownHostException e)  
        {  
            System.err.println("无法连接到服务器："+e.getMessage());  
        }catch (IOException e)  
        {  
            System.err.println("I/O错误："+e.getMessage());  
        }  
    }  
}
```

### **ServerSocket（TCP 服务端套接字）**

服务端监听指定端口，接受客户端连接，返回 Socket 对象。

#### 核心构造方法

|构造方法|说明|重点|
|---|---|---|
|`ServerSocket(int port)`|绑定指定端口（0-65535，1024 以下为系统端口）|端口被占用会抛`BindException`|
|`ServerSocket(int port, int backlog)`|指定等待连接的队列长度（backlog）|高并发需调大（默认 50）|

#### 核心方法

|方法|作用|重点|
|---|---|---|
|`Socket accept()`|阻塞等待客户端连接，返回与客户端通信的 Socket|核心阻塞方法，单线程仅能处理一个连接|
|`void bind(SocketAddress endpoint)`|手动绑定地址 / 端口|灵活配置|
|`void close()`|关闭服务端套接字|释放端口|
示例(实现TCP服务端)：

```java
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.ServerSocket;  
import java.net.Socket;  
  
public class TCPServer {  
    public static void main(String[] args) {  
        int port=8080;//设置端口号  
        try(ServerSocket server=new ServerSocket(port))  
        {  
            //等待客户端连接  
            while(true)  
            {  
                System.out.println("服务器已启动，等待客户端连接，端口："+port);  
                Socket acceptedSocket=server.accept();  
                System.out.println("客户端已连接，地址："+acceptedSocket.getRemoteSocketAddress());  
  
                //读取数据  
                try( BufferedReader in=new BufferedReader(new InputStreamReader(acceptedSocket.getInputStream()));  
                     PrintWriter out=new PrintWriter(acceptedSocket.getOutputStream(),true);  
                ) {  
                    String line;  
                    if ((line = in.readLine()) != null) {  
                        System.out.println("收到客户端消息：" + line);  
                        //发送响应  
                        out.println("服务器已收到消息：" + line);  
                    }  
                }  
            }  
        }catch (IOException e)  
        {  
            System.out.println("服务器异常："+e.getMessage());  
        }  
    }  
}
```

### DatagramSocket & DatagramPacket（UDP 核心）

UDP 无连接，核心是 “数据报” 而非流，需通过`DatagramPacket`封装数据 + 地址，`DatagramSocket`负责发送 / 接收。

#### DatagramSocket（UDP 套接字）

|构造方法|说明|
|---|---|
|`DatagramSocket()`|客户端使用（系统随机分配端口）|
|`DatagramSocket(int port)`|服务端使用（绑定指定端口）|

|核心方法|作用|
|---|---|
|`void send(DatagramPacket p)`|发送数据报|
|`void receive(DatagramPacket p)`|阻塞接收数据报|
|`void close()`|关闭套接字|

#### DatagramPacket（UDP 数据报）

|构造方法|说明|场景|
|---|---|---|
|`DatagramPacket(byte[] buf, int len, InetAddress addr, int port)`|封装数据 + 目标地址|发送|
|`DatagramPacket(byte[] buf, int len)`|仅封装缓冲区|接收|

|核心方法|作用|
|---|---|
|`byte[] getData()`|获取数据字节数组|
|`int getLength()`|获取有效数据长度（非缓冲区长度）|
|`InetAddress getAddress()`|获取源 / 目标 IP（接收 / 发送）|
|`int getPort()`|获取源 / 目标端口（接收 / 发送）|

示例：UDP服务端

```java
import java.io.IOException;  
import java.net.DatagramPacket;  
import java.net.DatagramSocket;  
import java.net.InetAddress;  
import java.net.SocketException;  
  
public class UDPServer {  
    public static void main(String[] args) {  
        int port=8080;  
        try(DatagramSocket socket =new DatagramSocket(port))  
        {  
            byte[] buffer=new byte[1024];  
            while(true)  
            {  
                //接收数据报  
                DatagramPacket packet=new DatagramPacket(buffer, buffer.length);  
                socket.receive(packet);  
                //处理接收到的数据报  
                String receivedData=new String(packet.getData(),0,packet.getLength());  
                System.out.println("接收到的数据为："+receivedData);  
                //响应客户端  
                InetAddress address = packet.getAddress();//获取客户端地址  
                int Clientport = packet.getPort();//获取客户端端口号  
                String responseData="这里是服务器响应，已收到数据";//响应客户端数据  
                byte[] responseBytes=responseData.getBytes();//转换成字节数组  
                DatagramPacket responsePacket = new DatagramPacket(responseBytes,responseBytes.length, address, Clientport);//创建响应数据报  
                socket.send(responsePacket);//发送数据报  
            }  
        } catch (SocketException e) {  
            System.out.println("Socket异常："+e.getMessage());  
        }  
        catch (IOException e)  
        {  
            System.out.println("服务器异常："+e.getMessage());  
        }  
  
    }  
}
```

UDP客户端：

```java
import java.net.*;  
  
public class UDPClient {  
    public static void main(String[] args) {  
        String serverAddress="localhost";  
        int port=8080;  
  
        try(DatagramSocket socket =new DatagramSocket())  
        {  
            InetAddress address = InetAddress.getByName(serverAddress);  
            //定义发送的数据  
            String message="Hello, UDP Server!";  
            byte[] sendData=message.getBytes();  
            //创建数据报  
            DatagramPacket packet =new DatagramPacket(sendData,sendData.length,address,port);  
            //发送数据报  
            socket.send(packet);  
            //创建数据报，用于接收服务器响应  
            byte[] receiveData=new byte[1024];  
            DatagramPacket responsePacket=new DatagramPacket(receiveData,receiveData.length);  
            //接收服务器响应  
            socket.receive(responsePacket);  
            String responseMessage=new String(responsePacket.getData(),0,responsePacket.getLength());  
            System.out.println("收到服务器响应："+responseMessage);  
        }catch (SocketException | UnknownHostException e)  
        {  
           e.printStackTrace();  
        }  
        catch (Exception e)  
        {  
            e.printStackTrace();  
        }  
    }  
}
```

总结一下服务器与客户端的互动逻辑：

服务器启动，等待客户端连接->启动客户端->建立连接->客户端发送数据->服务器接收数据->服务器响应客户端->客户端接受响应->关闭资源

###  URL/URLConnection（应用层协议）

**作用**：访问 HTTP/FTP 等应用层协议资源，无需关注底层 TCP/UDP。

**URL（统一资源定位符）**

```Java
import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.net.MalformedURLException;  
import java.net.URL;  
  
public class URLdemo {  
    public static void main(String[] args) {  
        try {  
            URL url = new URL("https://www.baidu.com");  
            try (BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()))) {  
  
                String line;  
                while ((line = br.readLine()) != null) {  
                    System.out.println(line);  
                }  
            } catch (Exception e) {  
                e.printStackTrace();  
            }  
        }catch (MalformedURLException e)  
        {  
            e.printStackTrace();  
        }  
    }  
}
```

