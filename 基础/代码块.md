# 代码块

Java 中的**代码块**是指用 `{}` 包裹的一段代码片段，根据「定义位置」和「修饰符」可分为 4 类核心场景

---

### 1.静态代码块（static{ })

类级别的代码块，定义在类内部，用于初始化属性

**关键特性**

- **执行时机**：类首次被使用时（触发类加载）执行，且**仅执行一次**（JVM 保证类加载仅一次）；
- **执行顺序**：多个静态代码块按「定义顺序」执行；且优先于「实例代码块」和「构造器」执行；
- **访问权限**：仅能访问「类级别的成员」（静态属性、静态方法），不能访问实例成员（`this`/`super` 关键字不可用）；
- **核心作用**：初始化静态属性（尤其是复杂逻辑赋值，如读取配置文件）、加载全局资源（如数据库驱动、注册工具类）。

实例：

```java
public class test_block {
    public static int data1;
    public static int data2;
    public int data3;
    static {
        data1=10;
        System.out.println("静态代码块1");
    }
    {
        System.out.println("实例代码块");
    }
    static {
        data2=20;
        System.out.println("静态代码块2");
    }
    public test_block() {
        System.out.println("构造器");
    }
}
```

结果：

```txt
静态代码块1
静态代码块2
实例代码块
构造器
```

### 2.实例代码块（{ }）

实例级别的代码，定义在类内部，依赖对象实例。

**关键特性**

- **执行时机**：每次通过 `new` 创建对象时执行，且**在构造器执行之前**执行；
- **执行顺序**：多个实例代码块按「定义顺序」执行；顺序为：静态代码块 → 实例代码块 → 构造器；
- **访问权限**：可访问「类级别成员」（静态属性 / 方法）和「实例级别成员」（实例属性 / 方法），支持 `this`/`super` 关键字；
- **核心作用**：抽取多个构造器的「公共代码」（如初始化实例属性、校验参数），减少代码重复。

```c++
class Person {
    private String name;
    private int age;

    // 实例代码块：抽取所有构造器的公共逻辑（校验年龄、初始化默认值）
    {
        System.out.println("实例代码块执行：校验年龄格式");
        //JVM 给 age 赋默认值 0，name 赋默认值 null；
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("年龄必须在 0-150 之间");
        }
        // 公共初始化：默认名称为"未知"
        this.name = "未知";
    }

    // 构造器1：无参构造
    public Person() {
        System.out.println("无参构造器执行");
        this.age = 18; // 默认年龄
    }

    // 构造器2：带参构造
    public Person(String name, int age) {
        this.age = age; // 先赋值年龄，再执行实例代码块的校验（注意执行顺序）
        System.out.println("带参构造器执行");
        this.name = name; // 覆盖实例代码块的默认名称
    }
}
```

### 3.局部代码块（方法内部 `{}`）

限制作用域，不多说

### 4.同步代码块（`synchronized (锁对象) {}`）

被 `synchronized` 修饰的代码块，通常定义在**方法内部**（也可在类内部），核心用于「多线程环境下保证代码原子性」。

- 锁定指定对象（锁对象可为 `this`、Class 对象、自定义对象），保证同一时间仅一个线程能执行块内代码（线程安全）；
- **执行时机**：线程获取到「锁对象」后执行，执行完毕释放锁，其他线程竞争锁；
- **锁对象要求**：必须是「引用类型」（不能是基本类型，如 `int`），且多个线程必须竞争「同一把锁」才有效；
- **对比同步方法**：同步代码块的「锁粒度更细」（仅锁定核心逻辑，而非整个方法），并发效率更高（单例模式中 DCL 的优化核心）。

```java
class Counter {
    private int count = 0;
    // 自定义锁对象（推荐：避免使用 this 或 Class 对象，降低锁竞争范围）
    private final Object lock = new Object();

    // 多线程并发调用的方法
    public void increment() {
        // 非核心逻辑（无需同步，提升并发效率）
        System.out.println(Thread.currentThread().getName() + " 开始执行");

        // 同步代码块：仅锁定"count自增"的核心逻辑
        synchronized (lock) {
            count++;
            System.out.println(Thread.currentThread().getName() + "：count = " + count);
        }

        // 非核心逻辑（无需同步）
        System.out.println(Thread.currentThread().getName() + " 执行结束");
    }
}
```

