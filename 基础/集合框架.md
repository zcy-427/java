# 集合框架

Java 集合框架（Collection Framework）是 JDK 提供的一套**用于存储、操作、管理一组对象**的标准化类 / 接口体系，位于 `java.util` 包下（并发安全集合在 `java.util.concurrent`）。它解决了数组「长度固定、类型单一、操作繁琐」的问题，是 Java 开发中最常用的核心组件之一。

## 框架体系

```txt
┌─────────────────────────────────────────┐
│              Collection<E> (接口)        │
├─────────────┬─────────────┬─────────────┤
│ List<E>     │ Set<E>      │ Queue<E>    │
│ (有序可重复) │ (无序不可重) │ (先进先出)  │
├─────────────┤ ├─────────────┤ ├─────────────┤
│ ArrayList   │ │ HashSet    │ │ LinkedList  │
│ LinkedList  │ │ LinkedHashSet│ │ ArrayDeque  │
│ Vector      │ │ TreeSet    │ │ PriorityQueue│
│ Stack       │ │            │ │             │
└─────────────┘ └─────────────┘ └─────────────┘

┌─────────────────────────────────────────┐
│              Map<K,V> (接口)             │
├─────────────┬─────────────┬─────────────┤
│ HashMap     │ TreeMap     │ Hashtable   │
│ LinkedHashMap│ ConcurrentHashMap │ Properties  │
└─────────────┴─────────────┴─────────────┘

┌─────────────────────────────────────────┐
│              迭代器/工具类               │
├─────────────┬─────────────┬─────────────┤
│ Iterator<E> │ Collections │ Arrays      │
│ ListIterator│             │             │
└─────────────┴─────────────┴─────────────┘
```

## 核心架构

整体分为两大体系：**单列集合（Collection）** 和 **双列集合（Map）**，二者无继承关系，但底层实现（如 `HashSet` 基于 `HashMap`）存在关联。

---

### 单列集合：Collection（根接口）

存储单个元素，定义了所有单列集合的通用方法（`add()`/`remove()`/`size()`/`iterator()` 等），核心子接口为 `List`、`Set`、`Queue`。

#### 核心方法

**添加元素**：

| 方法签名                                    | 核心作用                                   | 返回值    | 注意事项                                                     |
| ------------------------------------------- | ------------------------------------------ | --------- | ------------------------------------------------------------ |
| `boolean add(E e)`                          | 向集合中添加单个元素                       | `boolean` | - 大部分实现（如 ArrayList）始终返回 `true`；- Set 集合若元素重复则返回 `false`；- 部分实现（如 TreeSet）不允许添加 `null`，否则抛 `NullPointerException` |
| `boolean addAll(Collection<? extends E> c)` | 将另一个集合的**所有元素**添加到当前集合中 | `boolean` | - 只要添加了至少一个元素就返回 `true`；- 若目标集合为空 / 元素全重复，返回 `false` |

```java
Collection<String> coll = new ArrayList<>();
coll.add("Java"); // 返回 true
coll.add("Python"); // 返回 true
Collection<String> coll2 = new HashSet<>();
coll2.add("Java"); // 返回 true（首次添加）
coll2.add("Java"); // 返回 false（Set 重复）

coll.addAll(coll2); // 仅添加非重复元素，返回 true
```

**元素删除:** 

| 方法签名                                                | 核心作用                                               | 返回值    | 注意事项                                                     |
| ------------------------------------------------------- | ------------------------------------------------------ | --------- | ------------------------------------------------------------ |
| `boolean remove(Object o)`                              | 移除集合中**第一个匹配**的元素（基于 `equals()` 匹配） | `boolean` | - 找到并移除返回 `true`，否则 `false`；- 自定义对象需重写 `equals()`，否则按地址匹配 |
| `boolean removeAll(Collection<?> c)`                    | 移除当前集合中**所有在 c 中存在**的元素（求差集）      | `boolean` | 只要移除了至少一个元素就返回 `true`                          |
| `default boolean removeIf(Predicate<? super E> filter)` | JDK8+ 新增，移除所有满足条件的元素                     | `boolean` | 条件由 Lambda 表达式定义，移除成功返回 `true`                |
| `void clear()`                                          | 清空集合中**所有元素**（集合本身不销毁）               | 无        | 清空后 `size() == 0`，但集合对象仍可用                       |

```JAVA
Collection<String> coll = new ArrayList<>(Arrays.asList("A", "B", "C", "A"));
coll.remove("A"); // 移除第一个"A"，返回 true，集合变为 [B, C, A]
coll.removeAll(Arrays.asList("B", "D")); // 移除"B"，返回 true，集合变为 [C, A]
coll.removeIf(s -> s.startsWith("A")); // 移除"A"，返回 true，集合变为 [C]
coll.clear(); // 清空，集合变为 []
```

**查询与状态判断:**

| 方法签名                               | 核心作用                                           | 返回值    | 注意事项                                                     |
| -------------------------------------- | -------------------------------------------------- | --------- | ------------------------------------------------------------ |
| `int size()`                           | 返回集合中**元素的数量**                           | `int`     | 空集合返回 `0`，最大不超过 `Integer.MAX_VALUE`               |
| `boolean isEmpty()`                    | 判断集合是否为空（元素数量为 0）                   | `boolean` | 比 `size() == 0` 更高效（部分实现无需计算大小）              |
| `boolean contains(Object o)`           | 判断集合中是否包含指定元素（基于 `equals()` 匹配） | `boolean` | 自定义对象需重写 `equals()`/`hashCode()`（HashSet/HashMap 依赖） |
| `boolean containsAll(Collection<?> c)` | 判断当前集合是否**包含 c 中的所有元素**            | `boolean` | 若 c 为空，始终返回 `true`                                   |

```JAVA
Collection<String> coll = Arrays.asList("Java", "MySQL");
System.out.println(coll.size()); // 输出 2
System.out.println(coll.isEmpty()); // 输出 false
System.out.println(coll.contains("Java")); // 输出 true
System.out.println(coll.containsAll(Arrays.asList("Java", "Redis"))); // 输出 false
```

**遍历**

这里需要提到**迭代器**，是 Java 集合框架中**遍历单列集合（Collection）的标准化工具**

主要分为3种：

| 接口              | 出现版本 | 适用场景                           | 核心能力                                           | 核心方法                                                     |
| ----------------- | -------- | ---------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| `Iterator<E>`     | JDK 1.2  | 所有 `Collection` 集合             | 单向遍历、移除元素（通用迭代器）                   | `hasNext()`、`next()`、`remove()`、`forEachRemaining()`（JDK8+） |
| `ListIterator<E>` | JDK 1.2  | 仅 `List` 及其实现类               | 继承 `Iterator`，支持**双向遍历**、添加 / 修改元素 | 新增：`hasPrevious()`、`previous()`、`add(E)`、`set(E)`、`nextIndex()` |
| `Enumeration<E>`  | JDK 1.0  | 仅老旧集合（`Vector`/`Hashtable`） | 老旧迭代器，无移除能力，已被 `Iterator` 替代       | `hasMoreElements()`、`nextElement()`（无 `remove()`          |

其中`Iterator<E>`是重点，其适用于所有 `Collection` 集合

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorDemo {
    public static void main(String[] args) {
        Collection<String> coll = new ArrayList<>();
        coll.add("Java");
        coll.add("Python");
        coll.add("Go");

        // 1. 获取迭代器
        Iterator<String> it = coll.iterator();

        // 2. 遍历（推荐：先判断 hasNext()，再调用 next()）
        while (it.hasNext()) {//hasNext判断集合中是否还有未遍历的元素（迭代器是否能继续前进）
            String elem = it.next(); // next获取下一个元素，并将迭代器指针「向后移动一位」
            System.out.println(elem); // 输出：Java → Python → Go

            // 3. 安全移除元素（仅迭代器的 remove() 不会触发并发修改，线程安全
            if ("Python".equals(elem)) {
                it.remove(); // 移除 "Python"
            }
        }

        System.out.println(coll); // 输出：[Java, Go]

        // 4. JDK8+ forEachRemaining 遍历剩余元素（此时已遍历完，无输出）
        it.forEachRemaining(System.out::println);
    }
}
```

`ListIterator<E>` 是 `Iterator` 的子类，专为 `List` 设计，弥补了 `Iterator` 「只能向前遍历、无法修改 / 添加元素」的缺陷。

```java
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class ListIteratorDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // 1. 获取 ListIterator（可指定起始索引，此处从索引 2 开始）
        ListIterator<String> lit = list.listIterator(2);

        // 2. 反向遍历（从后往前）
        while (lit.hasPrevious()) {
            String elem = lit.previous();
            System.out.println("反向遍历：" + elem); // 输出：C → B
        }

        // 3. 向前遍历 + 修改元素
        while (lit.hasNext()) {
            String elem = lit.next();
            if ("B".equals(elem)) {
                lit.set("B-modified"); // 修改最后一次 next() 获取的元素
            }
            if ("C".equals(elem)) {
                lit.add("D"); // 在 C 后插入 D
            }
        }

        System.out.println(list); // 输出：[A, B-modified, C, D]
    }
}
```

`Enumeration` 是 JDK 1.0 提供的老旧迭代器，仅用于 `Vector`、`Hashtable` 等过时集合，**无移除 / 修改能力**，已被 `Iterator` 完全替代。了解即可

---

#### 核心接口

##### （1）List 接口：有序、可重复、有索引

「有序」指**插入顺序与遍历顺序一致**，「可重复」指允许存储相等元素（基于 `equals()`），支持通过索引访问元素。

| 实现类                 | 底层结构     | 线程安全           | 核心特点                                                     | 适用场景                     |
| ---------------------- | ------------ | ------------------ | ------------------------------------------------------------ | ---------------------------- |
| ArrayList              | 动态数组     | 否                 | 查询快（随机访问）、增删慢（需移动元素）；初始容量 10，扩容 1.5 倍（JDK8） | 读多写少、随机访问频繁       |
| LinkedList             | 双向链表     | 否                 | 增删快（仅改指针）、查询慢；实现 `Deque`，可作队列 / 栈      | 增删频繁、顺序访问（如队列） |
| Vector                 | 动态数组     | 是（synchronized） | 线程安全但效率低；初始容量 10，扩容 2 倍；几乎被 `ArrayList` 替代 | 老旧代码、简单线程安全场景   |
| `CopyOnWriteArrayList` | 写时复制数组 | 是                 | 读无锁、写复制数组；避免并发修改异常；写开销大               | 读多写少的并发场景           |

> 补充：`Stack` 继承 `Vector`（栈，后进先出），推荐用 `Deque`（`LinkedList`/`ArrayDeque`）替代。
>
> 即实现栈结构时，尽量使用`Deque`，

##### （2）Set 接口：无序、不可重复

「无序」默认指**无索引、插入顺序不保证**（`LinkedHashSet` 除外），「不可重复」指元素唯一（基于 `hashCode()` + `equals()`）。

| 实现类          | 底层结构                | 线程安全 | 核心特点                                                     | 适用场景                     |
| --------------- | ----------------------- | -------- | ------------------------------------------------------------ | ---------------------------- |
| `HashSet`       | `HashMap`（key 存元素） | 否       | 无序、允许 null（仅 1 个）；查询 / 增删效率高（O (1)）       | 普通去重场景                 |
| `LinkedHashSet` | `LinkedHashMap`         | 否       | 继承 HashSet，维护双向链表，保留插入顺序；性能略低于 HashSet | 去重且需保留插入顺序         |
| `TreeSet`       | `TreeMap`（红黑树）     | 否       | 有序（自然排序 / 自定义 Comparator）；不允许 null；元素需实现 `Comparable` | 去重且需排序（如按数值排序） |

##### （3）Queue 接口：队列（FIFO）

用于临时存储元素，强调「先进先出」，核心子接口 `Deque`（双端队列，可作栈 / 队列）、`BlockingQueue`（阻塞队列，并发场景）。

| 实现类                | 类型       | 线程安全 | 核心特点                                           | 适用场景               |
| --------------------- | ---------- | -------- | -------------------------------------------------- | ---------------------- |
| `LinkedList`          | 非阻塞队列 | 否       | 实现 `Deque`，支持双端操作                         | 普通非并发队列 / 栈    |
| `ArrayDeque`          | 循环数组   | 否       | 比 LinkedList 效率高；无容量限制（自动扩容）       | 高性能非阻塞双端队列   |
| `PriorityQueue`       | 二叉堆     | 否       | 优先级队列（非 FIFO）；元素需排序（自然 / 自定义） | 按优先级处理任务       |
| `ArrayBlockingQueue`  | 阻塞队列   | 是       | 数组实现、有界；生产者 - 消费者模型                | 固定容量的并发任务     |
| `LinkedBlockingQueue` | 阻塞队列   | 是       | 链表实现、可选界；吞吐量高于 `ArrayBlockingQueue`  | 高并发生产者 - 消费者  |
| `SynchronousQueue`    | 阻塞队列   | 是       | 无存储（仅传递）；生产方必须等待消费方             | 快速传递数据的并发场景 |

---

### 双列集合：Map（根接口）

存储「键值对（Key-Value）」，Key 唯一（`hashCode()` + `equals()`），Value 可重复；无继承 `Collection`，但可通过 `keySet()`/`values()`/`entrySet()` 转为单列集合遍历。

| 实现类              | 底层结构                             | 线程安全           | 核心特点                                                     | 适用场景                    |
| ------------------- | ------------------------------------ | ------------------ | ------------------------------------------------------------ | --------------------------- |
| `HashMap`           | 数组 + 链表 / 红黑树（JDK8）         | 否                 | 无序；允许 1 个 null Key、多个 null Value；初始容量 16，负载因子 0.75，扩容 2 倍 | 普通键值对存储（最常用）    |
| `LinkedHashMap`     | HashMap + 双向链表                   | 否                 | 保留插入 / 访问顺序；可实现 LRU 缓存                         | 键值对需有序（如 LRU 缓存） |
| `TreeMap`           | 红黑树                               | 否                 | 按 Key 排序（自然 / 自定义）；Key 需实现 `Comparable`；不允许 null Key | 键值对需排序                |
| `Hashtable`         | 数组 + 链表                          | 是（synchronized） | 不允许 null Key/Value；效率低；初始容量 11，扩容 2n+1        | 老旧代码、简单线程安全场景  |
| `ConcurrentHashMap` | CAS + 分段锁（JDK7）/ 节点锁（JDK8） | 是                 | 高并发安全；效率远高于 Hashtable；JDK8 不允许 null Key/Value | 高并发键值对存储            |
| `WeakHashMap`       | 数组 + 链表（Key 为弱引用）          | 否                 | Key 无强引用时会被 GC 回收；避免内存泄漏                     | 临时缓存（如缓存用户会话）  |

> 关键：HashMap JDK8 优化 —— 链表长度 >8 转红黑树（查询效率 O (n)→O (`logn`)），<6 转回链表（避免红黑树开销）。

---

### 核心辅助工具类

#### Collections

`Collections` 是专门操作 **Collection 体系**（List、Set、Map）的静态工具类，所有方法均为 `static`，且构造器被私有化（无法实例化）。

核心功能：

1.**不可变集合（Unmodifiable Collections）**

**作用**：封装原有集合，返回一个**不可修改的视图**（禁止 add/remove/set 等修改操作），用于保护集合不被意外篡改。

在Java9+后直接创建**真正不可变**的集合（而非视图，原集合不存在，性能更优）。

```java
List<String> mutableList = new ArrayList<>(Arrays.asList("A", "B"));
// 封装为不可变视图
List<String> unmodifiableList = Collections.unmodifiableList(mutableList);

// 尝试修改会抛出 UnsupportedOperationException
// unmodifiableList.add("C"); // 报错

// 注意：视图特性——修改原集合，不可变视图也会同步变化
mutableList.add("C");
System.out.println(unmodifiableList); // 输出 [A, B, C]

// Java9+ 真正不可变集合（无原集合，完全不可改）
List<String> trulyUnmodifiable = List.of("X", "Y");
// trulyUnmodifiable.add("Z"); // 报错
```

注意：

- `unmodifiableXXX` 是 “视图”，原集合修改会同步到视图；`of()` 是真正不可变集合，无原集合依赖。

- 仅禁止 “结构化修改”（add/remove），若集合元素是可变对象（如自定义类），元素内部属性仍可修改。

2.**同步集合（Synchronized Collections）**

**作用**：封装原有集合，返回**线程安全的同步版本**（通过 `synchronized` 关键字加锁），解决多线程下的并发修改问题。

```java
// 非线程安全的 ArrayList 包装为同步 List
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// 多线程环境下操作 syncList 可避免并发修改异常
new Thread(() -> syncList.add("A")).start();
new Thread(() -> System.out.println(syncList)).start();
```

注意：

- 仅保证**单个方法**的原子性，复合操作（如 `if (list.isEmpty()) list.add(...)`）仍需手动加锁。
- 性能较差（全局锁），高并发场景优先使用 `java.util.concurrent` 包的集合（如 `CopyOnWriteArrayList`、`ConcurrentHashMap`）。

3.**空集合（Empty Collections）**

**作用**：返回预定义的空集合实例，避免频繁创建新的空集合对象（节省内存）。

```java
// 方法返回空集合时，优先用 emptyList() 而非 new ArrayList<>()
public List<String> getEmptyData() {
    return Collections.emptyList(); // 复用单例，无内存开销
}
```

> 这里说一下**空集合的作用**：
>
> 如果方法在 “无数据” 时返回 `null` 而非空集合，调用方必须额外增加 `null` 判断，否则遍历、调用 `size()`/`isEmpty()`、`forEach()` 等操作时会直接抛出 `NullPointerException`；而返回空集合，调用方可直接操作，无需额外判空，代码更简洁、安全。

4.**单元素集合（Singleton Collections）**

**作用**：创建只包含一个元素的不可变集合，简化单元素集合的创建。

```java
Set<String> singleSet = Collections.singleton("test");
Map<String, Integer> singleMap = Collections.singletonMap("age", 20);
```

5.**排序与反转操作**

**作用**：对 List 进行排序、反转、随机打乱等操作（Set/Map 无索引，不支持）。

```java
List<Integer> list = new ArrayList<>(Arrays.asList(3, 1, 2));
// 自然排序（升序）
Collections.sort(list);
System.out.println(list); // [1, 2, 3]

// 自定义降序排序
Collections.sort(list, (a, b) -> b - a);
System.out.println(list); // [3, 2, 1]
//自定义排序时，可以传入Comparator比较器类
// 反转
Collections.reverse(list);
System.out.println(list); // [1, 2, 3]

// 随机打乱
Collections.shuffle(list);
```

6.**查找与替换操作**

**作用**：查找集合的最大 / 最小值、二分查找、填充元素、替换元素等。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
// 找最大值
System.out.println(Collections.max(list)); // 5

// 二分查找（list 已排序）
int index = Collections.binarySearch(list, 3);
System.out.println(index); // 2

// 填充
List<String> fillList = new ArrayList<>(3);
Collections.fill(fillList, "hello"); // [hello, hello, hello]
```

7.集合适配 / 转换

**核心方法**：

- `asLifoQueue(Deque<T> deque)`：将双端队列（Deque）适配为 LIFO（后进先出）队列。
- `newSetFromMap(Map<E, Boolean> map)`：用 Map 实现 Set（如基于 `ConcurrentHashMap` 构建线程安全的 Set）。

---

- [x] Arrays工具类 ✅ 2025-12-11
#### Arrays

`java.util.Arrays` 是 Java 核心类库中专门用于**操作数组**的静态工具类，提供了数组排序、查找、填充、比较、复制、转字符串 / 集合等一站式方法，覆盖所有基本类型数组（`byte[]`/`int[]`/`char[]` 等）和引用类型数组（`Object[]`），是处理数组的「瑞士军刀」。

##### 核心方法

1.**数组排序**

最常用的数组操作之一，分为「普通排序」和「并行排序」两类。

|方法签名|功能说明|
|---|---|
|`sort(基本类型数组)`|对整个数组原地排序，基本类型用**双轴快速排序**（Dual-Pivot QuickSort）|
|`sort(Object[])`|对引用类型数组排序，依赖元素实现 `Comparable` 接口，用 **TimSort**（归并 + 插入优化）|
|`sort(数组, int from, int to)`|对数组指定范围（左闭右开）排序|
|`sort(数组, Comparator)`|自定义比较器排序（无需元素实现 `Comparable`）|
|`parallelSort(数组)`|Java 8+ 并行排序，基于 Fork/Join 框架，适合百万级以上大数据量数组|

```java
import java.util.Arrays;  
import java.util.Comparator;  
  
class User implements Comparable<User>  
{  
    private int age;  
    private String name;  
  
    public User (){};  
    public User(String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    @Override  
    public int compareTo(User o) {  
        return this.age-o.age;  
    }  
    @Override  
    public String toString()  
    {  
        return "User{name='" + name + "', age=" + age + "}";  
    }  
}  
public class sort {  
    public static void main(String[] args) {  
        //基本数据类型排序  
        int[] arr = {5, 2, 8, 1, 3};  
        Arrays.sort(arr);  
        System.out.println(Arrays.toString(arr));  
        //引用数据类型排序  
        User[] users = {new User("zhang",16),new User("wang",17),new User("li",18)};  
        //1.User实现Comparable接口  
        Arrays.sort(users);  
        System.out.println(Arrays.toString(users));  
        //2.使用Comparator  
        Arrays.sort(users, Comparator.comparingInt(User::getAge).reversed());  
        System.out.println(Arrays.toString(users));  
  
        // 3. 指定范围排序（索引1到4，左闭右开）  
        int[] partial = {5, 2, 9, 1, 7, 3};  
        Arrays.sort(partial, 1, 4);  
        System.out.println(Arrays.toString(partial)); // [5, 1, 2, 9, 7, 3]  
  
    }  
}
```

 **2.数组查找（Binary Search）**

基于**二分查找算法**，**必须在已排序的数组**上使用，否则结果不可预测。

| 方法签名                                | 功能说明                                          |
| ----------------------------------- | --------------------------------------------- |
| `binarySearch(已排序数组, 目标值)`          | 查找目标值，找到返回索引；未找到返回 `-(插入点) - 1`（插入点 = 应插入的位置） |
| `binarySearch(数组, from, to, 目标值)`   | 指定范围查找                                        |
| `binarySearch(数组, 目标值, Comparator)` | 自定义比较器查找（适配未实现 Comparable 的引用类型）              |

```java
import java.util.Arrays;  
  
public class binarySearchdemo {  
    public static void main(String[] args) {  
        int[] sortedArr = {1, 3, 5, 7, 9, 11};  
  
        // 1. 找到目标值（返回索引3）  
        int index1 = Arrays.binarySearch(sortedArr, 7);  
        System.out.println(index1); // 3  
  
        // 2. 未找到目标值（插入点=4，返回 -4-1=-5）  
        int index2 = Arrays.binarySearch(sortedArr, 8);  
        System.out.println(index2); // -5  
  
        // 3. 指定范围查找（索引1到4，找5）  
        int index3 = Arrays.binarySearch(sortedArr, 1, 4, 5);  
        System.out.println(index3); // 2  
    }  
}
```

**3.数组填充（Fill）**

将指定值填充到数组的全部 / 指定范围元素中，**原地修改原数组**。

|方法签名|功能说明|
|---|---|
|`fill(数组, 填充值)`|填充整个数组|
|`fill(数组, from, to, 填充值)`|填充指定范围|

```java

```